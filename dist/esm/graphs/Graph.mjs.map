{"version":3,"file":"Graph.mjs","sources":["../../../src/graphs/Graph.ts"],"sourcesContent":["/* eslint-disable no-console */\n// src/graphs/Graph.ts\nimport { nanoid } from 'nanoid';\nimport { concat } from '@langchain/core/utils/stream';\nimport { ToolNode } from '@langchain/langgraph/prebuilt';\nimport { ChatVertexAI } from '@langchain/google-vertexai';\nimport {\n  START,\n  END,\n  Command,\n  StateGraph,\n  Annotation,\n  messagesStateReducer,\n} from '@langchain/langgraph';\nimport {\n  Runnable,\n  RunnableConfig,\n  RunnableLambda,\n} from '@langchain/core/runnables';\nimport {\n  ToolMessage,\n  SystemMessage,\n  AIMessageChunk,\n} from '@langchain/core/messages';\nimport type {\n  BaseMessageFields,\n  UsageMetadata,\n  BaseMessage,\n} from '@langchain/core/messages';\nimport type { ToolCall } from '@langchain/core/messages/tool';\nimport type * as t from '@/types';\nimport {\n  GraphNodeKeys,\n  ContentTypes,\n  GraphEvents,\n  Providers,\n  StepTypes,\n  Constants,\n} from '@/common';\nimport {\n  formatAnthropicArtifactContent,\n  ensureThinkingBlockInMessages,\n  convertMessagesToContent,\n  addBedrockCacheControl,\n  modifyDeltaProperties,\n  formatArtifactPayload,\n  formatContentStrings,\n  createPruneMessages,\n  addCacheControl,\n  extractToolDiscoveries,\n} from '@/messages';\nimport {\n  resetIfNotEmpty,\n  isOpenAILike,\n  isGoogleLike,\n  joinKeys,\n  sleep,\n} from '@/utils';\nimport { getChatModelClass, manualToolStreamProviders } from '@/llm/providers';\nimport { ToolNode as CustomToolNode, toolsCondition } from '@/tools/ToolNode';\nimport { ChatOpenAI, AzureChatOpenAI } from '@/llm/openai';\nimport { safeDispatchCustomEvent } from '@/utils/events';\nimport { AgentContext } from '@/agents/AgentContext';\nimport { createFakeStreamingLLM } from '@/llm/fake';\nimport { HandlerRegistry } from '@/events';\n\nconst { AGENT, TOOLS } = GraphNodeKeys;\n\nexport abstract class Graph<\n  T extends t.BaseGraphState = t.BaseGraphState,\n  _TNodeName extends string = string,\n> {\n  abstract resetValues(): void;\n  abstract initializeTools({\n    currentTools,\n    currentToolMap,\n  }: {\n    currentTools?: t.GraphTools;\n    currentToolMap?: t.ToolMap;\n  }): CustomToolNode<T> | ToolNode<T>;\n  abstract initializeModel({\n    currentModel,\n    tools,\n    clientOptions,\n  }: {\n    currentModel?: t.ChatModel;\n    tools?: t.GraphTools;\n    clientOptions?: t.ClientOptions;\n  }): Runnable;\n  abstract getRunMessages(): BaseMessage[] | undefined;\n  abstract getContentParts(): t.MessageContentComplex[] | undefined;\n  abstract generateStepId(stepKey: string): [string, number];\n  abstract getKeyList(\n    metadata: Record<string, unknown> | undefined\n  ): (string | number | undefined)[];\n  abstract getStepKey(metadata: Record<string, unknown> | undefined): string;\n  abstract checkKeyList(keyList: (string | number | undefined)[]): boolean;\n  abstract getStepIdByKey(stepKey: string, index?: number): string;\n  abstract getRunStep(stepId: string): t.RunStep | undefined;\n  abstract dispatchRunStep(\n    stepKey: string,\n    stepDetails: t.StepDetails,\n    metadata?: Record<string, unknown>\n  ): Promise<string>;\n  abstract dispatchRunStepDelta(\n    id: string,\n    delta: t.ToolCallDelta\n  ): Promise<void>;\n  abstract dispatchMessageDelta(\n    id: string,\n    delta: t.MessageDelta\n  ): Promise<void>;\n  abstract dispatchReasoningDelta(\n    stepId: string,\n    delta: t.ReasoningDelta\n  ): Promise<void>;\n  abstract handleToolCallCompleted(\n    data: t.ToolEndData,\n    metadata?: Record<string, unknown>,\n    omitOutput?: boolean\n  ): Promise<void>;\n\n  abstract createCallModel(\n    agentId?: string,\n    currentModel?: t.ChatModel\n  ): (state: T, config?: RunnableConfig) => Promise<Partial<T>>;\n  messageStepHasToolCalls: Map<string, boolean> = new Map();\n  messageIdsByStepKey: Map<string, string> = new Map();\n  prelimMessageIdsByStepKey: Map<string, string> = new Map();\n  config: RunnableConfig | undefined;\n  contentData: t.RunStep[] = [];\n  stepKeyIds: Map<string, string[]> = new Map<string, string[]>();\n  contentIndexMap: Map<string, number> = new Map();\n  toolCallStepIds: Map<string, string> = new Map();\n  signal?: AbortSignal;\n  /** Set of invoked tool call IDs from non-message run steps completed mid-run, if any */\n  invokedToolIds?: Set<string>;\n  handlerRegistry: HandlerRegistry | undefined;\n  /**\n   * Tool session contexts for automatic state persistence across tool invocations.\n   * Keyed by tool name (e.g., Constants.EXECUTE_CODE).\n   * Currently supports code execution session tracking (session_id, files).\n   */\n  sessions: t.ToolSessionMap = new Map();\n}\n\nexport class StandardGraph extends Graph<t.BaseGraphState, t.GraphNode> {\n  overrideModel?: t.ChatModel;\n  /** Optional compile options passed into workflow.compile() */\n  compileOptions?: t.CompileOptions | undefined;\n  messages: BaseMessage[] = [];\n  runId: string | undefined;\n  startIndex: number = 0;\n  signal?: AbortSignal;\n  /** Map of agent contexts by agent ID */\n  agentContexts: Map<string, AgentContext> = new Map();\n  /** Default agent ID to use */\n  defaultAgentId: string;\n\n  constructor({\n    // parent-level graph inputs\n    runId,\n    signal,\n    agents,\n    tokenCounter,\n    indexTokenCountMap,\n  }: t.StandardGraphInput) {\n    super();\n    this.runId = runId;\n    this.signal = signal;\n\n    if (agents.length === 0) {\n      throw new Error('At least one agent configuration is required');\n    }\n\n    for (const agentConfig of agents) {\n      const agentContext = AgentContext.fromConfig(\n        agentConfig,\n        tokenCounter,\n        indexTokenCountMap\n      );\n\n      this.agentContexts.set(agentConfig.agentId, agentContext);\n    }\n\n    this.defaultAgentId = agents[0].agentId;\n  }\n\n  /* Init */\n\n  resetValues(keepContent?: boolean): void {\n    this.messages = [];\n    this.config = resetIfNotEmpty(this.config, undefined);\n    if (keepContent !== true) {\n      this.contentData = resetIfNotEmpty(this.contentData, []);\n      this.contentIndexMap = resetIfNotEmpty(this.contentIndexMap, new Map());\n    }\n    this.stepKeyIds = resetIfNotEmpty(this.stepKeyIds, new Map());\n    this.toolCallStepIds = resetIfNotEmpty(this.toolCallStepIds, new Map());\n    this.messageIdsByStepKey = resetIfNotEmpty(\n      this.messageIdsByStepKey,\n      new Map()\n    );\n    this.messageStepHasToolCalls = resetIfNotEmpty(\n      this.messageStepHasToolCalls,\n      new Map()\n    );\n    this.prelimMessageIdsByStepKey = resetIfNotEmpty(\n      this.prelimMessageIdsByStepKey,\n      new Map()\n    );\n    this.invokedToolIds = resetIfNotEmpty(this.invokedToolIds, undefined);\n    for (const context of this.agentContexts.values()) {\n      context.reset();\n    }\n  }\n\n  /* Run Step Processing */\n\n  getRunStep(stepId: string): t.RunStep | undefined {\n    const index = this.contentIndexMap.get(stepId);\n    if (index !== undefined) {\n      return this.contentData[index];\n    }\n    return undefined;\n  }\n\n  getAgentContext(metadata: Record<string, unknown> | undefined): AgentContext {\n    if (!metadata) {\n      throw new Error('No metadata provided to retrieve agent context');\n    }\n\n    const currentNode = metadata.langgraph_node as string;\n    if (!currentNode) {\n      throw new Error(\n        'No langgraph_node in metadata to retrieve agent context'\n      );\n    }\n\n    let agentId: string | undefined;\n    if (currentNode.startsWith(AGENT)) {\n      agentId = currentNode.substring(AGENT.length);\n    } else if (currentNode.startsWith(TOOLS)) {\n      agentId = currentNode.substring(TOOLS.length);\n    }\n\n    const agentContext = this.agentContexts.get(agentId ?? '');\n    if (!agentContext) {\n      throw new Error(`No agent context found for agent ID ${agentId}`);\n    }\n\n    return agentContext;\n  }\n\n  getStepKey(metadata: Record<string, unknown> | undefined): string {\n    if (!metadata) return '';\n\n    const keyList = this.getKeyList(metadata);\n    if (this.checkKeyList(keyList)) {\n      throw new Error('Missing metadata');\n    }\n\n    return joinKeys(keyList);\n  }\n\n  getStepIdByKey(stepKey: string, index?: number): string {\n    const stepIds = this.stepKeyIds.get(stepKey);\n    if (!stepIds) {\n      throw new Error(`No step IDs found for stepKey ${stepKey}`);\n    }\n\n    if (index === undefined) {\n      return stepIds[stepIds.length - 1];\n    }\n\n    return stepIds[index];\n  }\n\n  generateStepId(stepKey: string): [string, number] {\n    const stepIds = this.stepKeyIds.get(stepKey);\n    let newStepId: string | undefined;\n    let stepIndex = 0;\n    if (stepIds) {\n      stepIndex = stepIds.length;\n      newStepId = `step_${nanoid()}`;\n      stepIds.push(newStepId);\n      this.stepKeyIds.set(stepKey, stepIds);\n    } else {\n      newStepId = `step_${nanoid()}`;\n      this.stepKeyIds.set(stepKey, [newStepId]);\n    }\n\n    return [newStepId, stepIndex];\n  }\n\n  getKeyList(\n    metadata: Record<string, unknown> | undefined\n  ): (string | number | undefined)[] {\n    if (!metadata) return [];\n\n    const keyList = [\n      metadata.run_id as string,\n      metadata.thread_id as string,\n      metadata.langgraph_node as string,\n      metadata.langgraph_step as number,\n      metadata.checkpoint_ns as string,\n    ];\n\n    const agentContext = this.getAgentContext(metadata);\n    if (\n      agentContext.currentTokenType === ContentTypes.THINK ||\n      agentContext.currentTokenType === 'think_and_text'\n    ) {\n      keyList.push('reasoning');\n    } else if (agentContext.tokenTypeSwitch === 'content') {\n      keyList.push('post-reasoning');\n    }\n\n    if (this.invokedToolIds != null && this.invokedToolIds.size > 0) {\n      keyList.push(this.invokedToolIds.size + '');\n    }\n\n    return keyList;\n  }\n\n  checkKeyList(keyList: (string | number | undefined)[]): boolean {\n    return keyList.some((key) => key === undefined);\n  }\n\n  /* Misc.*/\n\n  getRunMessages(): BaseMessage[] | undefined {\n    return this.messages.slice(this.startIndex);\n  }\n\n  getContentParts(): t.MessageContentComplex[] | undefined {\n    return convertMessagesToContent(this.messages.slice(this.startIndex));\n  }\n\n  /**\n   * Get all run steps, optionally filtered by agent ID\n   */\n  getRunSteps(agentId?: string): t.RunStep[] {\n    if (agentId == null || agentId === '') {\n      return [...this.contentData];\n    }\n    return this.contentData.filter((step) => step.agentId === agentId);\n  }\n\n  /**\n   * Get run steps grouped by agent ID\n   */\n  getRunStepsByAgent(): Map<string, t.RunStep[]> {\n    const stepsByAgent = new Map<string, t.RunStep[]>();\n\n    for (const step of this.contentData) {\n      if (step.agentId == null || step.agentId === '') continue;\n\n      const steps = stepsByAgent.get(step.agentId) ?? [];\n      steps.push(step);\n      stepsByAgent.set(step.agentId, steps);\n    }\n\n    return stepsByAgent;\n  }\n\n  /**\n   * Get agent IDs that participated in this run\n   */\n  getActiveAgentIds(): string[] {\n    const agentIds = new Set<string>();\n    for (const step of this.contentData) {\n      if (step.agentId != null && step.agentId !== '') {\n        agentIds.add(step.agentId);\n      }\n    }\n    return Array.from(agentIds);\n  }\n\n  /**\n   * Maps contentPart indices to agent IDs for post-run analysis\n   * Returns a map where key is the contentPart index and value is the agentId\n   */\n  getContentPartAgentMap(): Map<number, string> {\n    const contentPartAgentMap = new Map<number, string>();\n\n    for (const step of this.contentData) {\n      if (\n        step.agentId != null &&\n        step.agentId !== '' &&\n        Number.isFinite(step.index)\n      ) {\n        contentPartAgentMap.set(step.index, step.agentId);\n      }\n    }\n\n    return contentPartAgentMap;\n  }\n\n  /* Graph */\n\n  createSystemRunnable({\n    provider,\n    clientOptions,\n    instructions,\n    additional_instructions,\n  }: {\n    provider?: Providers;\n    clientOptions?: t.ClientOptions;\n    instructions?: string;\n    additional_instructions?: string;\n  }): t.SystemRunnable | undefined {\n    let finalInstructions: string | BaseMessageFields | undefined =\n      instructions;\n    if (additional_instructions != null && additional_instructions !== '') {\n      finalInstructions =\n        finalInstructions != null && finalInstructions\n          ? `${finalInstructions}\\n\\n${additional_instructions}`\n          : additional_instructions;\n    }\n\n    if (\n      finalInstructions != null &&\n      finalInstructions &&\n      provider === Providers.ANTHROPIC &&\n      ((\n        (clientOptions as t.AnthropicClientOptions).clientOptions\n          ?.defaultHeaders as Record<string, string> | undefined\n      )?.['anthropic-beta']?.includes('prompt-caching') ??\n        false)\n    ) {\n      finalInstructions = {\n        content: [\n          {\n            type: 'text',\n            text: instructions,\n            cache_control: { type: 'ephemeral' },\n          },\n        ],\n      };\n    }\n\n    if (finalInstructions != null && finalInstructions !== '') {\n      const systemMessage = new SystemMessage(finalInstructions);\n      return RunnableLambda.from((messages: BaseMessage[]) => {\n        return [systemMessage, ...messages];\n      }).withConfig({ runName: 'prompt' });\n    }\n  }\n\n  initializeTools({\n    currentTools,\n    currentToolMap,\n    agentContext,\n  }: {\n    currentTools?: t.GraphTools;\n    currentToolMap?: t.ToolMap;\n    agentContext?: AgentContext;\n  }): CustomToolNode<t.BaseGraphState> | ToolNode<t.BaseGraphState> {\n    return new CustomToolNode<t.BaseGraphState>({\n      tools: (currentTools as t.GenericTool[] | undefined) ?? [],\n      toolMap: currentToolMap,\n      toolCallStepIds: this.toolCallStepIds,\n      errorHandler: (data, metadata) =>\n        StandardGraph.handleToolCallErrorStatic(this, data, metadata),\n      toolRegistry: agentContext?.toolRegistry,\n      sessions: this.sessions,\n    });\n  }\n\n  initializeModel({\n    provider,\n    tools,\n    clientOptions,\n  }: {\n    provider: Providers;\n    tools?: t.GraphTools;\n    clientOptions?: t.ClientOptions;\n  }): Runnable {\n    const ChatModelClass = getChatModelClass(provider);\n    const model = new ChatModelClass(clientOptions ?? {});\n\n    if (\n      isOpenAILike(provider) &&\n      (model instanceof ChatOpenAI || model instanceof AzureChatOpenAI)\n    ) {\n      model.temperature = (clientOptions as t.OpenAIClientOptions)\n        .temperature as number;\n      model.topP = (clientOptions as t.OpenAIClientOptions).topP as number;\n      model.frequencyPenalty = (clientOptions as t.OpenAIClientOptions)\n        .frequencyPenalty as number;\n      model.presencePenalty = (clientOptions as t.OpenAIClientOptions)\n        .presencePenalty as number;\n      model.n = (clientOptions as t.OpenAIClientOptions).n as number;\n    } else if (\n      provider === Providers.VERTEXAI &&\n      model instanceof ChatVertexAI\n    ) {\n      model.temperature = (clientOptions as t.VertexAIClientOptions)\n        .temperature as number;\n      model.topP = (clientOptions as t.VertexAIClientOptions).topP as number;\n      model.topK = (clientOptions as t.VertexAIClientOptions).topK as number;\n      model.topLogprobs = (clientOptions as t.VertexAIClientOptions)\n        .topLogprobs as number;\n      model.frequencyPenalty = (clientOptions as t.VertexAIClientOptions)\n        .frequencyPenalty as number;\n      model.presencePenalty = (clientOptions as t.VertexAIClientOptions)\n        .presencePenalty as number;\n      model.maxOutputTokens = (clientOptions as t.VertexAIClientOptions)\n        .maxOutputTokens as number;\n    }\n\n    if (!tools || tools.length === 0) {\n      return model as unknown as Runnable;\n    }\n\n    return (model as t.ModelWithTools).bindTools(tools);\n  }\n\n  overrideTestModel(\n    responses: string[],\n    sleep?: number,\n    toolCalls?: ToolCall[]\n  ): void {\n    this.overrideModel = createFakeStreamingLLM({\n      responses,\n      sleep,\n      toolCalls,\n    });\n  }\n\n  getNewModel({\n    provider,\n    clientOptions,\n  }: {\n    provider: Providers;\n    clientOptions?: t.ClientOptions;\n  }): t.ChatModelInstance {\n    const ChatModelClass = getChatModelClass(provider);\n    return new ChatModelClass(clientOptions ?? {});\n  }\n\n  getUsageMetadata(\n    finalMessage?: BaseMessage\n  ): Partial<UsageMetadata> | undefined {\n    if (\n      finalMessage &&\n      'usage_metadata' in finalMessage &&\n      finalMessage.usage_metadata != null\n    ) {\n      return finalMessage.usage_metadata as Partial<UsageMetadata>;\n    }\n  }\n\n  /** Execute model invocation with streaming support */\n  private async attemptInvoke(\n    {\n      currentModel,\n      finalMessages,\n      provider,\n      tools,\n    }: {\n      currentModel?: t.ChatModel;\n      finalMessages: BaseMessage[];\n      provider: Providers;\n      tools?: t.GraphTools;\n    },\n    config?: RunnableConfig\n  ): Promise<Partial<t.BaseGraphState>> {\n    const model = this.overrideModel ?? currentModel;\n    if (!model) {\n      throw new Error('No model found');\n    }\n\n    if ((tools?.length ?? 0) > 0 && manualToolStreamProviders.has(provider)) {\n      if (!model.stream) {\n        throw new Error('Model does not support stream');\n      }\n      const stream = await model.stream(finalMessages, config);\n      let finalChunk: AIMessageChunk | undefined;\n      for await (const chunk of stream) {\n        await safeDispatchCustomEvent(\n          GraphEvents.CHAT_MODEL_STREAM,\n          { chunk, emitted: true },\n          config\n        );\n        finalChunk = finalChunk ? concat(finalChunk, chunk) : chunk;\n      }\n      finalChunk = modifyDeltaProperties(provider, finalChunk);\n      return { messages: [finalChunk as AIMessageChunk] };\n    } else {\n      const finalMessage = await model.invoke(finalMessages, config);\n      if ((finalMessage.tool_calls?.length ?? 0) > 0) {\n        finalMessage.tool_calls = finalMessage.tool_calls?.filter(\n          (tool_call: ToolCall) => !!tool_call.name\n        );\n      }\n      return { messages: [finalMessage] };\n    }\n  }\n\n  cleanupSignalListener(currentModel?: t.ChatModel): void {\n    if (!this.signal) {\n      return;\n    }\n    const model = this.overrideModel ?? currentModel;\n    if (!model) {\n      return;\n    }\n    const client = (model as ChatOpenAI | undefined)?.exposedClient;\n    if (!client?.abortHandler) {\n      return;\n    }\n    this.signal.removeEventListener('abort', client.abortHandler);\n    client.abortHandler = undefined;\n  }\n\n  createCallModel(agentId = 'default') {\n    return async (\n      state: t.BaseGraphState,\n      config?: RunnableConfig\n    ): Promise<Partial<t.BaseGraphState>> => {\n      /**\n       * Get agent context - it must exist by this point\n       */\n      const agentContext = this.agentContexts.get(agentId);\n      if (!agentContext) {\n        throw new Error(`Agent context not found for agentId: ${agentId}`);\n      }\n\n      if (!config) {\n        throw new Error('No config provided');\n      }\n\n      const { messages } = state;\n\n      // Extract tool discoveries from current turn only (similar to formatArtifactPayload pattern)\n      const discoveredNames = extractToolDiscoveries(messages);\n      if (discoveredNames.length > 0) {\n        agentContext.markToolsAsDiscovered(discoveredNames);\n      }\n\n      const toolsForBinding = agentContext.getToolsForBinding();\n      let model =\n        this.overrideModel ??\n        this.initializeModel({\n          tools: toolsForBinding,\n          provider: agentContext.provider,\n          clientOptions: agentContext.clientOptions,\n        });\n\n      if (agentContext.systemRunnable) {\n        model = agentContext.systemRunnable.pipe(model as Runnable);\n      }\n\n      if (agentContext.tokenCalculationPromise) {\n        await agentContext.tokenCalculationPromise;\n      }\n      if (!config.signal) {\n        config.signal = this.signal;\n      }\n      this.config = config;\n\n      let messagesToUse = messages;\n      if (\n        !agentContext.pruneMessages &&\n        agentContext.tokenCounter &&\n        agentContext.maxContextTokens != null &&\n        agentContext.indexTokenCountMap[0] != null\n      ) {\n        const isAnthropicWithThinking =\n          (agentContext.provider === Providers.ANTHROPIC &&\n            (agentContext.clientOptions as t.AnthropicClientOptions).thinking !=\n              null) ||\n          (agentContext.provider === Providers.BEDROCK &&\n            (agentContext.clientOptions as t.BedrockAnthropicInput)\n              .additionalModelRequestFields?.['thinking'] != null) ||\n          (agentContext.provider === Providers.OPENAI &&\n            (\n              (agentContext.clientOptions as t.OpenAIClientOptions).modelKwargs\n                ?.thinking as t.AnthropicClientOptions['thinking']\n            )?.type === 'enabled');\n\n        agentContext.pruneMessages = createPruneMessages({\n          startIndex: this.startIndex,\n          provider: agentContext.provider,\n          tokenCounter: agentContext.tokenCounter,\n          maxTokens: agentContext.maxContextTokens,\n          thinkingEnabled: isAnthropicWithThinking,\n          indexTokenCountMap: agentContext.indexTokenCountMap,\n        });\n      }\n      if (agentContext.pruneMessages) {\n        const { context, indexTokenCountMap } = agentContext.pruneMessages({\n          messages,\n          usageMetadata: agentContext.currentUsage,\n          // startOnMessageType: 'human',\n        });\n        agentContext.indexTokenCountMap = indexTokenCountMap;\n        messagesToUse = context;\n      }\n\n      let finalMessages = messagesToUse;\n      if (agentContext.useLegacyContent) {\n        finalMessages = formatContentStrings(finalMessages);\n      }\n\n      const lastMessageX =\n        finalMessages.length >= 2\n          ? finalMessages[finalMessages.length - 2]\n          : null;\n      const lastMessageY =\n        finalMessages.length >= 1\n          ? finalMessages[finalMessages.length - 1]\n          : null;\n\n      if (\n        agentContext.provider === Providers.BEDROCK &&\n        lastMessageX instanceof AIMessageChunk &&\n        lastMessageY instanceof ToolMessage &&\n        typeof lastMessageX.content === 'string'\n      ) {\n        finalMessages[finalMessages.length - 2].content = '';\n      }\n\n      const isLatestToolMessage = lastMessageY instanceof ToolMessage;\n\n      if (\n        isLatestToolMessage &&\n        agentContext.provider === Providers.ANTHROPIC\n      ) {\n        formatAnthropicArtifactContent(finalMessages);\n      } else if (\n        isLatestToolMessage &&\n        ((isOpenAILike(agentContext.provider) &&\n          agentContext.provider !== Providers.DEEPSEEK) ||\n          isGoogleLike(agentContext.provider))\n      ) {\n        formatArtifactPayload(finalMessages);\n      }\n\n      if (agentContext.provider === Providers.ANTHROPIC) {\n        const anthropicOptions = agentContext.clientOptions as\n          | t.AnthropicClientOptions\n          | undefined;\n        const defaultHeaders = anthropicOptions?.clientOptions\n          ?.defaultHeaders as Record<string, string> | undefined;\n        const anthropicBeta = defaultHeaders?.['anthropic-beta'];\n\n        if (\n          typeof anthropicBeta === 'string' &&\n          anthropicBeta.includes('prompt-caching')\n        ) {\n          finalMessages = addCacheControl<BaseMessage>(finalMessages);\n        }\n      } else if (agentContext.provider === Providers.BEDROCK) {\n        const bedrockOptions = agentContext.clientOptions as\n          | t.BedrockAnthropicClientOptions\n          | undefined;\n        if (bedrockOptions?.promptCache === true) {\n          finalMessages = addBedrockCacheControl<BaseMessage>(finalMessages);\n        }\n      }\n\n      /**\n       * Handle edge case: when switching from a non-thinking agent to a thinking-enabled agent,\n       * convert AI messages with tool calls to HumanMessages to avoid thinking block requirements.\n       * This is required by Anthropic/Bedrock when thinking is enabled.\n       */\n      const isAnthropicWithThinking =\n        (agentContext.provider === Providers.ANTHROPIC &&\n          (agentContext.clientOptions as t.AnthropicClientOptions).thinking !=\n            null) ||\n        (agentContext.provider === Providers.BEDROCK &&\n          (agentContext.clientOptions as t.BedrockAnthropicInput)\n            .additionalModelRequestFields?.['thinking'] != null);\n\n      if (isAnthropicWithThinking) {\n        finalMessages = ensureThinkingBlockInMessages(\n          finalMessages,\n          agentContext.provider\n        );\n      }\n\n      if (\n        agentContext.lastStreamCall != null &&\n        agentContext.streamBuffer != null\n      ) {\n        const timeSinceLastCall = Date.now() - agentContext.lastStreamCall;\n        if (timeSinceLastCall < agentContext.streamBuffer) {\n          const timeToWait =\n            Math.ceil((agentContext.streamBuffer - timeSinceLastCall) / 1000) *\n            1000;\n          await sleep(timeToWait);\n        }\n      }\n\n      agentContext.lastStreamCall = Date.now();\n\n      let result: Partial<t.BaseGraphState> | undefined;\n      const fallbacks =\n        (agentContext.clientOptions as t.LLMConfig | undefined)?.fallbacks ??\n        [];\n\n      if (finalMessages.length === 0) {\n        throw new Error(\n          JSON.stringify({\n            type: 'empty_messages',\n            info: 'Message pruning removed all messages as none fit in the context window. Please increase the context window size or make your message shorter.',\n          })\n        );\n      }\n\n      try {\n        result = await this.attemptInvoke(\n          {\n            currentModel: model,\n            finalMessages,\n            provider: agentContext.provider,\n            tools: agentContext.tools,\n          },\n          config\n        );\n      } catch (primaryError) {\n        let lastError: unknown = primaryError;\n        for (const fb of fallbacks) {\n          try {\n            let model = this.getNewModel({\n              provider: fb.provider,\n              clientOptions: fb.clientOptions,\n            });\n            const bindableTools = agentContext.tools;\n            model = (\n              !bindableTools || bindableTools.length === 0\n                ? model\n                : model.bindTools(bindableTools)\n            ) as t.ChatModelInstance;\n            result = await this.attemptInvoke(\n              {\n                currentModel: model,\n                finalMessages,\n                provider: fb.provider,\n                tools: agentContext.tools,\n              },\n              config\n            );\n            lastError = undefined;\n            break;\n          } catch (e) {\n            lastError = e;\n            continue;\n          }\n        }\n        if (lastError !== undefined) {\n          throw lastError;\n        }\n      }\n\n      if (!result) {\n        throw new Error('No result after model invocation');\n      }\n      agentContext.currentUsage = this.getUsageMetadata(result.messages?.[0]);\n      this.cleanupSignalListener();\n      return result;\n    };\n  }\n\n  createAgentNode(agentId: string): t.CompiledAgentWorfklow {\n    const agentContext = this.agentContexts.get(agentId);\n    if (!agentContext) {\n      throw new Error(`Agent context not found for agentId: ${agentId}`);\n    }\n\n    const agentNode = `${AGENT}${agentId}` as const;\n    const toolNode = `${TOOLS}${agentId}` as const;\n\n    const routeMessage = (\n      state: t.BaseGraphState,\n      config?: RunnableConfig\n    ): string => {\n      this.config = config;\n      return toolsCondition(state, toolNode, this.invokedToolIds);\n    };\n\n    const StateAnnotation = Annotation.Root({\n      messages: Annotation<BaseMessage[]>({\n        reducer: messagesStateReducer,\n        default: () => [],\n      }),\n    });\n\n    const workflow = new StateGraph(StateAnnotation)\n      .addNode(agentNode, this.createCallModel(agentId))\n      .addNode(\n        toolNode,\n        this.initializeTools({\n          currentTools: agentContext.tools,\n          currentToolMap: agentContext.toolMap,\n          agentContext,\n        })\n      )\n      .addEdge(START, agentNode)\n      .addConditionalEdges(agentNode, routeMessage)\n      .addEdge(toolNode, agentContext.toolEnd ? END : agentNode);\n\n    // Cast to unknown to avoid tight coupling to external types; options are opt-in\n    return workflow.compile(this.compileOptions as unknown as never);\n  }\n\n  createWorkflow(): t.CompiledStateWorkflow {\n    /** Use the default (first) agent for now */\n    const agentNode = this.createAgentNode(this.defaultAgentId);\n    const StateAnnotation = Annotation.Root({\n      messages: Annotation<BaseMessage[]>({\n        reducer: (a, b) => {\n          if (!a.length) {\n            this.startIndex = a.length + b.length;\n          }\n          const result = messagesStateReducer(a, b);\n          this.messages = result;\n          return result;\n        },\n        default: () => [],\n      }),\n    });\n    const workflow = new StateGraph(StateAnnotation)\n      .addNode(this.defaultAgentId, agentNode, { ends: [END] })\n      .addEdge(START, this.defaultAgentId)\n      .compile();\n\n    return workflow;\n  }\n\n  /**\n   * Indicates if this is a multi-agent graph.\n   * Override in MultiAgentGraph to return true.\n   * Used to conditionally include agentId in RunStep for frontend rendering.\n   */\n  protected isMultiAgentGraph(): boolean {\n    return false;\n  }\n\n  /**\n   * Get the parallel group ID for an agent, if any.\n   * Override in MultiAgentGraph to provide actual group IDs.\n   * Group IDs are incrementing numbers (1, 2, 3...) reflecting execution order.\n   * @param _agentId - The agent ID to look up\n   * @returns undefined for StandardGraph (no parallel groups), or group number for MultiAgentGraph\n   */\n  protected getParallelGroupIdForAgent(_agentId: string): number | undefined {\n    return undefined;\n  }\n\n  /* Dispatchers */\n\n  /**\n   * Dispatches a run step to the client, returns the step ID\n   */\n  async dispatchRunStep(\n    stepKey: string,\n    stepDetails: t.StepDetails,\n    metadata?: Record<string, unknown>\n  ): Promise<string> {\n    if (!this.config) {\n      throw new Error('No config provided');\n    }\n\n    const [stepId, stepIndex] = this.generateStepId(stepKey);\n    if (stepDetails.type === StepTypes.TOOL_CALLS && stepDetails.tool_calls) {\n      for (const tool_call of stepDetails.tool_calls) {\n        const toolCallId = tool_call.id ?? '';\n        if (!toolCallId || this.toolCallStepIds.has(toolCallId)) {\n          continue;\n        }\n        this.toolCallStepIds.set(toolCallId, stepId);\n      }\n    }\n\n    const runStep: t.RunStep = {\n      stepIndex,\n      id: stepId,\n      type: stepDetails.type,\n      index: this.contentData.length,\n      stepDetails,\n      usage: null,\n    };\n\n    const runId = this.runId ?? '';\n    if (runId) {\n      runStep.runId = runId;\n    }\n\n    /**\n     * Extract agentId and parallelGroupId from metadata\n     * Only set agentId for MultiAgentGraph (so frontend knows when to show agent labels)\n     */\n    if (metadata) {\n      try {\n        const agentContext = this.getAgentContext(metadata);\n        if (this.isMultiAgentGraph() && agentContext.agentId) {\n          // Only include agentId for MultiAgentGraph - enables frontend to show agent labels\n          runStep.agentId = agentContext.agentId;\n          // Set group ID if this agent is part of a parallel group\n          // Group IDs are incrementing numbers (1, 2, 3...) reflecting execution order\n          const groupId = this.getParallelGroupIdForAgent(agentContext.agentId);\n          if (groupId != null) {\n            runStep.groupId = groupId;\n          }\n        }\n      } catch (_e) {\n        /** If we can't get agent context, that's okay - agentId remains undefined */\n      }\n    }\n\n    this.contentData.push(runStep);\n    this.contentIndexMap.set(stepId, runStep.index);\n    await safeDispatchCustomEvent(\n      GraphEvents.ON_RUN_STEP,\n      runStep,\n      this.config\n    );\n    return stepId;\n  }\n\n  async handleToolCallCompleted(\n    data: t.ToolEndData,\n    metadata?: Record<string, unknown>,\n    omitOutput?: boolean\n  ): Promise<void> {\n    if (!this.config) {\n      throw new Error('No config provided');\n    }\n\n    if (!data.output) {\n      return;\n    }\n\n    const { input, output: _output } = data;\n    if ((_output as Command | undefined)?.lg_name === 'Command') {\n      return;\n    }\n    const output = _output as ToolMessage;\n    const { tool_call_id } = output;\n    const stepId = this.toolCallStepIds.get(tool_call_id) ?? '';\n    if (!stepId) {\n      throw new Error(`No stepId found for tool_call_id ${tool_call_id}`);\n    }\n\n    const runStep = this.getRunStep(stepId);\n    if (!runStep) {\n      throw new Error(`No run step found for stepId ${stepId}`);\n    }\n\n    /**\n     * Extract and store code execution session context from artifacts.\n     * Only update session_id when files are generated - this ensures we don't\n     * lose the original session that contains the files.\n     */\n    const toolName = output.name;\n    if (\n      toolName === Constants.EXECUTE_CODE ||\n      toolName === Constants.PROGRAMMATIC_TOOL_CALLING\n    ) {\n      const artifact = output.artifact as t.CodeExecutionArtifact | undefined;\n      const newFiles = artifact?.files ?? [];\n      const hasNewFiles = newFiles.length > 0;\n\n      if (\n        hasNewFiles &&\n        artifact?.session_id != null &&\n        artifact.session_id !== ''\n      ) {\n        /**\n         * Files were generated - update session with the new session_id.\n         * The new session_id is the one that contains these files.\n         */\n        const existingSession = this.sessions.get(Constants.EXECUTE_CODE) as\n          | t.CodeSessionContext\n          | undefined;\n        const existingFiles = existingSession?.files ?? [];\n\n        this.sessions.set(Constants.EXECUTE_CODE, {\n          session_id: artifact.session_id,\n          files: [...existingFiles, ...newFiles],\n          lastUpdated: Date.now(),\n        });\n      }\n    }\n\n    const dispatchedOutput =\n      typeof output.content === 'string'\n        ? output.content\n        : JSON.stringify(output.content);\n\n    const args = typeof input === 'string' ? input : input.input;\n    const tool_call = {\n      args: typeof args === 'string' ? args : JSON.stringify(args),\n      name: output.name ?? '',\n      id: output.tool_call_id,\n      output: omitOutput === true ? '' : dispatchedOutput,\n      progress: 1,\n    };\n\n    await this.handlerRegistry\n      ?.getHandler(GraphEvents.ON_RUN_STEP_COMPLETED)\n      ?.handle(\n        GraphEvents.ON_RUN_STEP_COMPLETED,\n        {\n          result: {\n            id: stepId,\n            index: runStep.index,\n            type: 'tool_call',\n            tool_call,\n          } as t.ToolCompleteEvent,\n        },\n        metadata,\n        this\n      );\n  }\n  /**\n   * Static version of handleToolCallError to avoid creating strong references\n   * that prevent garbage collection\n   */\n  static async handleToolCallErrorStatic(\n    graph: StandardGraph,\n    data: t.ToolErrorData,\n    metadata?: Record<string, unknown>\n  ): Promise<void> {\n    if (!graph.config) {\n      throw new Error('No config provided');\n    }\n\n    if (!data.id) {\n      console.warn('No Tool ID provided for Tool Error');\n      return;\n    }\n\n    const stepId = graph.toolCallStepIds.get(data.id) ?? '';\n    if (!stepId) {\n      throw new Error(`No stepId found for tool_call_id ${data.id}`);\n    }\n\n    const { name, input: args, error } = data;\n\n    const runStep = graph.getRunStep(stepId);\n    if (!runStep) {\n      throw new Error(`No run step found for stepId ${stepId}`);\n    }\n\n    const tool_call: t.ProcessedToolCall = {\n      id: data.id,\n      name: name || '',\n      args: typeof args === 'string' ? args : JSON.stringify(args),\n      output: `Error processing tool${error?.message != null ? `: ${error.message}` : ''}`,\n      progress: 1,\n    };\n\n    await graph.handlerRegistry\n      ?.getHandler(GraphEvents.ON_RUN_STEP_COMPLETED)\n      ?.handle(\n        GraphEvents.ON_RUN_STEP_COMPLETED,\n        {\n          result: {\n            id: stepId,\n            index: runStep.index,\n            type: 'tool_call',\n            tool_call,\n          } as t.ToolCompleteEvent,\n        },\n        metadata,\n        graph\n      );\n  }\n\n  /**\n   * Instance method that delegates to the static method\n   * Kept for backward compatibility\n   */\n  async handleToolCallError(\n    data: t.ToolErrorData,\n    metadata?: Record<string, unknown>\n  ): Promise<void> {\n    await StandardGraph.handleToolCallErrorStatic(this, data, metadata);\n  }\n\n  async dispatchRunStepDelta(\n    id: string,\n    delta: t.ToolCallDelta\n  ): Promise<void> {\n    if (!this.config) {\n      throw new Error('No config provided');\n    } else if (!id) {\n      throw new Error('No step ID found');\n    }\n    const runStepDelta: t.RunStepDeltaEvent = {\n      id,\n      delta,\n    };\n    await safeDispatchCustomEvent(\n      GraphEvents.ON_RUN_STEP_DELTA,\n      runStepDelta,\n      this.config\n    );\n  }\n\n  async dispatchMessageDelta(id: string, delta: t.MessageDelta): Promise<void> {\n    if (!this.config) {\n      throw new Error('No config provided');\n    }\n    const messageDelta: t.MessageDeltaEvent = {\n      id,\n      delta,\n    };\n    await safeDispatchCustomEvent(\n      GraphEvents.ON_MESSAGE_DELTA,\n      messageDelta,\n      this.config\n    );\n  }\n\n  dispatchReasoningDelta = async (\n    stepId: string,\n    delta: t.ReasoningDelta\n  ): Promise<void> => {\n    if (!this.config) {\n      throw new Error('No config provided');\n    }\n    const reasoningDelta: t.ReasoningDeltaEvent = {\n      id: stepId,\n      delta,\n    };\n    await safeDispatchCustomEvent(\n      GraphEvents.ON_REASONING_DELTA,\n      reasoningDelta,\n      this.config\n    );\n  };\n}\n"],"names":["CustomToolNode"],"mappings":"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"}