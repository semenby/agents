{"version":3,"file":"prune.mjs","sources":["../../../src/messages/prune.ts"],"sourcesContent":["import {\n  AIMessage,\n  BaseMessage,\n  UsageMetadata,\n} from '@langchain/core/messages';\nimport type {\n  ThinkingContentText,\n  MessageContentComplex,\n  ReasoningContentText,\n} from '@/types/stream';\nimport type { TokenCounter } from '@/types/run';\nimport { ContentTypes, Providers } from '@/common';\n\nexport type PruneMessagesFactoryParams = {\n  provider?: Providers;\n  maxTokens: number;\n  startIndex: number;\n  tokenCounter: TokenCounter;\n  indexTokenCountMap: Record<string, number | undefined>;\n  thinkingEnabled?: boolean;\n};\nexport type PruneMessagesParams = {\n  messages: BaseMessage[];\n  usageMetadata?: Partial<UsageMetadata>;\n  startType?: ReturnType<BaseMessage['getType']>;\n};\n\nfunction isIndexInContext(\n  arrayA: unknown[],\n  arrayB: unknown[],\n  targetIndex: number\n): boolean {\n  const startingIndexInA = arrayA.length - arrayB.length;\n  return targetIndex >= startingIndexInA;\n}\n\nfunction addThinkingBlock(\n  message: AIMessage,\n  thinkingBlock: ThinkingContentText | ReasoningContentText\n): AIMessage {\n  const content: MessageContentComplex[] = Array.isArray(message.content)\n    ? (message.content as MessageContentComplex[])\n    : [\n      {\n        type: ContentTypes.TEXT,\n        text: message.content,\n      },\n    ];\n  /** Edge case, the message already has the thinking block */\n  if (content[0].type === thinkingBlock.type) {\n    return message;\n  }\n  content.unshift(thinkingBlock);\n  return new AIMessage({\n    ...message,\n    content,\n  });\n}\n\n/**\n * Calculates the total tokens from a single usage object\n *\n * @param usage The usage metadata object containing token information\n * @returns An object containing the total input and output tokens\n */\nexport function calculateTotalTokens(\n  usage: Partial<UsageMetadata>\n): UsageMetadata {\n  const baseInputTokens = Number(usage.input_tokens) || 0;\n  const cacheCreation = Number(usage.input_token_details?.cache_creation) || 0;\n  const cacheRead = Number(usage.input_token_details?.cache_read) || 0;\n\n  const totalInputTokens = baseInputTokens + cacheCreation + cacheRead;\n  const totalOutputTokens = Number(usage.output_tokens) || 0;\n\n  return {\n    input_tokens: totalInputTokens,\n    output_tokens: totalOutputTokens,\n    total_tokens: totalInputTokens + totalOutputTokens,\n  };\n}\n\nexport type PruningResult = {\n  context: BaseMessage[];\n  remainingContextTokens: number;\n  messagesToRefine: BaseMessage[];\n  thinkingStartIndex?: number;\n};\n\n/**\n * Processes an array of messages and returns a context of messages that fit within a specified token limit.\n * It iterates over the messages from newest to oldest, adding them to the context until the token limit is reached.\n *\n * @param options Configuration options for processing messages\n * @returns Object containing the message context, remaining tokens, messages not included, and summary index\n */\nexport function getMessagesWithinTokenLimit({\n  messages: _messages,\n  maxContextTokens,\n  indexTokenCountMap,\n  startType: _startType,\n  thinkingEnabled,\n  tokenCounter,\n  thinkingStartIndex: _thinkingStartIndex = -1,\n  reasoningType = ContentTypes.THINKING,\n}: {\n  messages: BaseMessage[];\n  maxContextTokens: number;\n  indexTokenCountMap: Record<string, number | undefined>;\n  startType?: string | string[];\n  thinkingEnabled?: boolean;\n  tokenCounter: TokenCounter;\n  thinkingStartIndex?: number;\n  reasoningType?: ContentTypes.THINKING | ContentTypes.REASONING_CONTENT;\n}): PruningResult {\n  // Every reply is primed with <|start|>assistant<|message|>, so we\n  // start with 3 tokens for the label after all messages have been counted.\n  let currentTokenCount = 3;\n  const instructions =\n    _messages[0]?.getType() === 'system' ? _messages[0] : undefined;\n  const instructionsTokenCount =\n    instructions != null ? (indexTokenCountMap[0] ?? 0) : 0;\n  const initialContextTokens = maxContextTokens - instructionsTokenCount;\n  let remainingContextTokens = initialContextTokens;\n  let startType = _startType;\n  const originalLength = _messages.length;\n  const messages = [..._messages];\n  /**\n   * IMPORTANT: this context array gets reversed at the end, since the latest messages get pushed first.\n   *\n   * This may be confusing to read, but it is done to ensure the context is in the correct order for the model.\n   * */\n  let context: Array<BaseMessage | undefined> = [];\n\n  let thinkingStartIndex = _thinkingStartIndex;\n  let thinkingEndIndex = -1;\n  let thinkingBlock: ThinkingContentText | ReasoningContentText | undefined;\n  const endIndex = instructions != null ? 1 : 0;\n  const prunedMemory: BaseMessage[] = [];\n\n  if (_thinkingStartIndex > -1) {\n    const thinkingMessageContent = messages[_thinkingStartIndex]?.content;\n    if (Array.isArray(thinkingMessageContent)) {\n      thinkingBlock = thinkingMessageContent.find(\n        (content) => content.type === reasoningType\n      ) as ThinkingContentText | undefined;\n    }\n  }\n\n  if (currentTokenCount < remainingContextTokens) {\n    let currentIndex = messages.length;\n    while (\n      messages.length > 0 &&\n      currentTokenCount < remainingContextTokens &&\n      currentIndex > endIndex\n    ) {\n      currentIndex--;\n      if (messages.length === 1 && instructions) {\n        break;\n      }\n      const poppedMessage = messages.pop();\n      if (!poppedMessage) continue;\n      const messageType = poppedMessage.getType();\n      if (\n        thinkingEnabled === true &&\n        thinkingEndIndex === -1 &&\n        currentIndex === originalLength - 1 &&\n        (messageType === 'ai' || messageType === 'tool')\n      ) {\n        thinkingEndIndex = currentIndex;\n      }\n      if (\n        thinkingEndIndex > -1 &&\n        !thinkingBlock &&\n        thinkingStartIndex < 0 &&\n        messageType === 'ai' &&\n        Array.isArray(poppedMessage.content)\n      ) {\n        thinkingBlock = poppedMessage.content.find(\n          (content) => content.type === reasoningType\n        ) as ThinkingContentText | undefined;\n        thinkingStartIndex = thinkingBlock != null ? currentIndex : -1;\n      }\n      /** False start, the latest message was not part of a multi-assistant/tool sequence of messages */\n      if (\n        thinkingEndIndex > -1 &&\n        currentIndex === thinkingEndIndex - 1 &&\n        messageType !== 'ai' &&\n        messageType !== 'tool'\n      ) {\n        thinkingEndIndex = -1;\n      }\n\n      const tokenCount = indexTokenCountMap[currentIndex] ?? 0;\n\n      if (\n        prunedMemory.length === 0 &&\n        currentTokenCount + tokenCount <= remainingContextTokens\n      ) {\n        context.push(poppedMessage);\n        currentTokenCount += tokenCount;\n      } else {\n        prunedMemory.push(poppedMessage);\n        if (thinkingEndIndex > -1 && thinkingStartIndex < 0) {\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (context[context.length - 1]?.getType() === 'tool') {\n      startType = ['ai', 'human'];\n    }\n\n    if (startType != null && startType.length > 0 && context.length > 0) {\n      let requiredTypeIndex = -1;\n\n      let totalTokens = 0;\n      for (let i = context.length - 1; i >= 0; i--) {\n        const currentType = context[i]?.getType() ?? '';\n        if (\n          Array.isArray(startType)\n            ? startType.includes(currentType)\n            : currentType === startType\n        ) {\n          requiredTypeIndex = i + 1;\n          break;\n        }\n        const originalIndex = originalLength - 1 - i;\n        totalTokens += indexTokenCountMap[originalIndex] ?? 0;\n      }\n\n      if (requiredTypeIndex > 0) {\n        currentTokenCount -= totalTokens;\n        context = context.slice(0, requiredTypeIndex);\n      }\n    }\n  }\n\n  if (instructions && originalLength > 0) {\n    context.push(_messages[0] as BaseMessage);\n    messages.shift();\n  }\n\n  remainingContextTokens -= currentTokenCount;\n  const result: PruningResult = {\n    remainingContextTokens,\n    context: [] as BaseMessage[],\n    messagesToRefine: prunedMemory,\n  };\n\n  if (thinkingStartIndex > -1) {\n    result.thinkingStartIndex = thinkingStartIndex;\n  }\n\n  if (\n    prunedMemory.length === 0 ||\n    thinkingEndIndex < 0 ||\n    (thinkingStartIndex > -1 &&\n      isIndexInContext(_messages, context, thinkingStartIndex))\n  ) {\n    // we reverse at this step to ensure the context is in the correct order for the model, and we need to work backwards\n    result.context = context.reverse() as BaseMessage[];\n    return result;\n  }\n\n  if (thinkingEndIndex > -1 && thinkingStartIndex < 0) {\n    throw new Error(\n      'The payload is malformed. There is a thinking sequence but no \"AI\" messages with thinking blocks.'\n    );\n  }\n\n  if (!thinkingBlock) {\n    throw new Error(\n      'The payload is malformed. There is a thinking sequence but no thinking block found.'\n    );\n  }\n\n  // Since we have a thinking sequence, we need to find the last assistant message\n  // in the latest AI/tool sequence to add the thinking block that falls outside of the current context\n  // Latest messages are ordered first.\n  let assistantIndex = -1;\n  for (let i = 0; i < context.length; i++) {\n    const currentMessage = context[i];\n    const type = currentMessage?.getType();\n    if (type === 'ai') {\n      assistantIndex = i;\n    }\n    if (assistantIndex > -1 && (type === 'human' || type === 'system')) {\n      break;\n    }\n  }\n\n  if (assistantIndex === -1) {\n    throw new Error(\n      'The payload is malformed. There is a thinking sequence but no \"AI\" messages to append thinking blocks to.'\n    );\n  }\n\n  thinkingStartIndex = originalLength - 1 - assistantIndex;\n  const thinkingTokenCount = tokenCounter(\n    new AIMessage({ content: [thinkingBlock] })\n  );\n  const newRemainingCount = remainingContextTokens - thinkingTokenCount;\n  const newMessage = addThinkingBlock(\n    context[assistantIndex] as AIMessage,\n    thinkingBlock\n  );\n  context[assistantIndex] = newMessage;\n  if (newRemainingCount > 0) {\n    result.context = context.reverse() as BaseMessage[];\n    return result;\n  }\n\n  const thinkingMessage: AIMessage = context[assistantIndex] as AIMessage;\n  // now we need to an additional round of pruning but making the thinking block fit\n  const newThinkingMessageTokenCount =\n    (indexTokenCountMap[thinkingStartIndex] ?? 0) + thinkingTokenCount;\n  remainingContextTokens = initialContextTokens - newThinkingMessageTokenCount;\n  currentTokenCount = 3;\n  let newContext: BaseMessage[] = [];\n  const secondRoundMessages = [..._messages];\n  let currentIndex = secondRoundMessages.length;\n  while (\n    secondRoundMessages.length > 0 &&\n    currentTokenCount < remainingContextTokens &&\n    currentIndex > thinkingStartIndex\n  ) {\n    currentIndex--;\n    const poppedMessage = secondRoundMessages.pop();\n    if (!poppedMessage) continue;\n    const tokenCount = indexTokenCountMap[currentIndex] ?? 0;\n    if (currentTokenCount + tokenCount <= remainingContextTokens) {\n      newContext.push(poppedMessage);\n      currentTokenCount += tokenCount;\n    } else {\n      messages.push(poppedMessage);\n      break;\n    }\n  }\n\n  const firstMessage: AIMessage = newContext[newContext.length - 1];\n  const firstMessageType = newContext[newContext.length - 1].getType();\n  if (firstMessageType === 'tool') {\n    startType = ['ai', 'human'];\n  }\n\n  if (startType != null && startType.length > 0 && newContext.length > 0) {\n    let requiredTypeIndex = -1;\n\n    let totalTokens = 0;\n    for (let i = newContext.length - 1; i >= 0; i--) {\n      const currentType = newContext[i]?.getType() ?? '';\n      if (\n        Array.isArray(startType)\n          ? startType.includes(currentType)\n          : currentType === startType\n      ) {\n        requiredTypeIndex = i + 1;\n        break;\n      }\n      const originalIndex = originalLength - 1 - i;\n      totalTokens += indexTokenCountMap[originalIndex] ?? 0;\n    }\n\n    if (requiredTypeIndex > 0) {\n      currentTokenCount -= totalTokens;\n      newContext = newContext.slice(0, requiredTypeIndex);\n    }\n  }\n\n  if (firstMessageType === 'ai') {\n    const newMessage = addThinkingBlock(firstMessage, thinkingBlock);\n    newContext[newContext.length - 1] = newMessage;\n  } else {\n    newContext.push(thinkingMessage);\n  }\n\n  if (instructions && originalLength > 0) {\n    newContext.push(_messages[0] as BaseMessage);\n    secondRoundMessages.shift();\n  }\n\n  result.context = newContext.reverse();\n  return result;\n}\n\nexport function checkValidNumber(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value) && value > 0;\n}\n\ntype ThinkingBlocks = {\n  thinking_blocks?: Array<{\n    type: 'thinking';\n    thinking: string;\n    signature: string;\n  }>;\n};\n\nexport function createPruneMessages(factoryParams: PruneMessagesFactoryParams) {\n  const indexTokenCountMap = { ...factoryParams.indexTokenCountMap };\n  let lastTurnStartIndex = factoryParams.startIndex;\n  let lastCutOffIndex = 0;\n  let totalTokens = Object.values(indexTokenCountMap).reduce(\n    (a = 0, b = 0) => a + b,\n    0\n  ) as number;\n  let runThinkingStartIndex = -1;\n  return function pruneMessages(params: PruneMessagesParams): {\n    context: BaseMessage[];\n    indexTokenCountMap: Record<string, number | undefined>;\n  } {\n    if (\n      factoryParams.provider === Providers.OPENAI &&\n      factoryParams.thinkingEnabled === true\n    ) {\n      for (let i = lastTurnStartIndex; i < params.messages.length; i++) {\n        const m = params.messages[i];\n        if (\n          m.getType() === 'ai' &&\n          typeof m.additional_kwargs.reasoning_content === 'string' &&\n          Array.isArray(\n            (\n              m.additional_kwargs.provider_specific_fields as\n                | ThinkingBlocks\n                | undefined\n            )?.thinking_blocks\n          ) &&\n          (m as AIMessage).tool_calls &&\n          ((m as AIMessage).tool_calls?.length ?? 0) > 0\n        ) {\n          const message = m as AIMessage;\n          const thinkingBlocks = (\n            message.additional_kwargs.provider_specific_fields as ThinkingBlocks\n          ).thinking_blocks;\n          const signature =\n            thinkingBlocks?.[thinkingBlocks.length - 1].signature;\n          const thinkingBlock: ThinkingContentText = {\n            signature,\n            type: ContentTypes.THINKING,\n            thinking: message.additional_kwargs.reasoning_content as string,\n          };\n\n          params.messages[i] = new AIMessage({\n            ...message,\n            content: [thinkingBlock],\n            additional_kwargs: {\n              ...message.additional_kwargs,\n              reasoning_content: undefined,\n            },\n          });\n        }\n      }\n    }\n\n    let currentUsage: UsageMetadata | undefined;\n    if (\n      params.usageMetadata &&\n      (checkValidNumber(params.usageMetadata.input_tokens) ||\n        (checkValidNumber(params.usageMetadata.input_token_details) &&\n          (checkValidNumber(\n            params.usageMetadata.input_token_details.cache_creation\n          ) ||\n            checkValidNumber(\n              params.usageMetadata.input_token_details.cache_read\n            )))) &&\n      checkValidNumber(params.usageMetadata.output_tokens)\n    ) {\n      currentUsage = calculateTotalTokens(params.usageMetadata);\n      totalTokens = currentUsage.total_tokens;\n    }\n\n    const newOutputs = new Set<number>();\n    for (let i = lastTurnStartIndex; i < params.messages.length; i++) {\n      const message = params.messages[i];\n      if (\n        i === lastTurnStartIndex &&\n        indexTokenCountMap[i] === undefined &&\n        currentUsage\n      ) {\n        indexTokenCountMap[i] = currentUsage.output_tokens;\n      } else if (indexTokenCountMap[i] === undefined) {\n        indexTokenCountMap[i] = factoryParams.tokenCounter(message);\n        if (currentUsage) {\n          newOutputs.add(i);\n        }\n        totalTokens += indexTokenCountMap[i] ?? 0;\n      }\n    }\n\n    // If `currentUsage` is defined, we need to distribute the current total tokens to our `indexTokenCountMap`,\n    // We must distribute it in a weighted manner, so that the total token count is equal to `currentUsage.total_tokens`,\n    // relative the manually counted tokens in `indexTokenCountMap`.\n    // EDGE CASE: when the resulting context gets pruned, we should not distribute the usage for messages that are not in the context.\n    if (currentUsage) {\n      let totalIndexTokens = 0;\n      if (params.messages[0].getType() === 'system') {\n        totalIndexTokens += indexTokenCountMap[0] ?? 0;\n      }\n      for (let i = lastCutOffIndex; i < params.messages.length; i++) {\n        if (i === 0 && params.messages[0].getType() === 'system') {\n          continue;\n        }\n        if (newOutputs.has(i)) {\n          continue;\n        }\n        totalIndexTokens += indexTokenCountMap[i] ?? 0;\n      }\n\n      // Calculate ratio based only on messages that remain in the context\n      const ratio = currentUsage.total_tokens / totalIndexTokens;\n      const isRatioSafe = ratio >= 1 / 3 && ratio <= 2.5;\n\n      // Apply the ratio adjustment only to messages at or after lastCutOffIndex, and only if the ratio is safe\n      if (isRatioSafe) {\n        if (\n          params.messages[0].getType() === 'system' &&\n          lastCutOffIndex !== 0\n        ) {\n          indexTokenCountMap[0] = Math.round(\n            (indexTokenCountMap[0] ?? 0) * ratio\n          );\n        }\n\n        for (let i = lastCutOffIndex; i < params.messages.length; i++) {\n          if (newOutputs.has(i)) {\n            continue;\n          }\n          indexTokenCountMap[i] = Math.round(\n            (indexTokenCountMap[i] ?? 0) * ratio\n          );\n        }\n      }\n    }\n\n    lastTurnStartIndex = params.messages.length;\n    if (lastCutOffIndex === 0 && totalTokens <= factoryParams.maxTokens) {\n      return { context: params.messages, indexTokenCountMap };\n    }\n\n    const { context, thinkingStartIndex } = getMessagesWithinTokenLimit({\n      maxContextTokens: factoryParams.maxTokens,\n      messages: params.messages,\n      indexTokenCountMap,\n      startType: params.startType,\n      thinkingEnabled: factoryParams.thinkingEnabled,\n      tokenCounter: factoryParams.tokenCounter,\n      reasoningType:\n        factoryParams.provider === Providers.BEDROCK\n          ? ContentTypes.REASONING_CONTENT\n          : ContentTypes.THINKING,\n      thinkingStartIndex:\n        factoryParams.thinkingEnabled === true\n          ? runThinkingStartIndex\n          : undefined,\n    });\n    runThinkingStartIndex = thinkingStartIndex ?? -1;\n    /** The index is the first value of `context`, index relative to `params.messages` */\n    lastCutOffIndex = Math.max(\n      params.messages.length -\n        (context.length - (context[0]?.getType() === 'system' ? 1 : 0)),\n      0\n    );\n\n    return { context, indexTokenCountMap };\n  };\n}\n"],"names":[],"mappings":"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"}