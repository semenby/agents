{"version":3,"file":"index.mjs","sources":["../../../../src/llm/bedrock/index.ts"],"sourcesContent":["/**\n * Optimized ChatBedrockConverse wrapper that fixes contentBlockIndex conflicts\n *\n * Bedrock sends the same contentBlockIndex for both text and tool_use content blocks,\n * causing LangChain's merge logic to fail with \"field[contentBlockIndex] already exists\"\n * errors. This wrapper simply strips contentBlockIndex from response_metadata to avoid\n * the conflict.\n *\n * The contentBlockIndex field is only used internally by Bedrock's streaming protocol\n * and isn't needed by application logic - the index field on tool_call_chunks serves\n * the purpose of tracking tool call ordering.\n */\n\nimport { ChatBedrockConverse } from '@langchain/aws';\nimport type { ChatBedrockConverseInput } from '@langchain/aws';\nimport { AIMessageChunk } from '@langchain/core/messages';\nimport type { BaseMessage } from '@langchain/core/messages';\nimport { ChatGenerationChunk } from '@langchain/core/outputs';\nimport type { CallbackManagerForLLMRun } from '@langchain/core/callbacks/manager';\n\nexport class CustomChatBedrockConverse extends ChatBedrockConverse {\n  constructor(fields?: ChatBedrockConverseInput) {\n    super(fields);\n  }\n\n  static lc_name(): string {\n    return 'LibreChatBedrockConverse';\n  }\n\n  /**\n   * Override _streamResponseChunks to strip contentBlockIndex from response_metadata\n   * This prevents LangChain's merge conflicts when the same index is used for\n   * different content types (text vs tool calls)\n   */\n  async *_streamResponseChunks(\n    messages: BaseMessage[],\n    options: this['ParsedCallOptions'],\n    runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    const baseStream = super._streamResponseChunks(\n      messages,\n      options,\n      runManager\n    );\n\n    for await (const chunk of baseStream) {\n      // Only process if we have response_metadata\n      if (\n        chunk.message instanceof AIMessageChunk &&\n        (chunk.message as Partial<AIMessageChunk>).response_metadata &&\n        typeof chunk.message.response_metadata === 'object'\n      ) {\n        // Check if contentBlockIndex exists anywhere in response_metadata (top level or nested)\n        const hasContentBlockIndex = this.hasContentBlockIndex(\n          chunk.message.response_metadata\n        );\n\n        if (hasContentBlockIndex) {\n          const cleanedMetadata = this.removeContentBlockIndex(\n            chunk.message.response_metadata\n          ) as Record<string, unknown>;\n\n          yield new ChatGenerationChunk({\n            text: chunk.text,\n            message: new AIMessageChunk({\n              ...chunk.message,\n              response_metadata: cleanedMetadata,\n            }),\n            generationInfo: chunk.generationInfo,\n          });\n          continue;\n        }\n      }\n\n      yield chunk;\n    }\n  }\n\n  /**\n   * Check if contentBlockIndex exists at any level in the object\n   */\n  private hasContentBlockIndex(obj: unknown): boolean {\n    if (obj === null || obj === undefined || typeof obj !== 'object') {\n      return false;\n    }\n\n    if ('contentBlockIndex' in obj) {\n      return true;\n    }\n\n    for (const value of Object.values(obj)) {\n      if (typeof value === 'object' && value !== null) {\n        if (this.hasContentBlockIndex(value)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Recursively remove contentBlockIndex from all levels of an object\n   */\n  private removeContentBlockIndex(obj: unknown): unknown {\n    if (obj === null || obj === undefined) {\n      return obj;\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map((item) => this.removeContentBlockIndex(item));\n    }\n\n    if (typeof obj === 'object') {\n      const cleaned: Record<string, unknown> = {};\n      for (const [key, value] of Object.entries(obj)) {\n        if (key !== 'contentBlockIndex') {\n          cleaned[key] = this.removeContentBlockIndex(value);\n        }\n      }\n      return cleaned;\n    }\n\n    return obj;\n  }\n}\n\nexport type { ChatBedrockConverseInput };\n"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;AAWG;AASG,MAAO,yBAA0B,SAAQ,mBAAmB,CAAA;AAChE,IAAA,WAAA,CAAY,MAAiC,EAAA;QAC3C,KAAK,CAAC,MAAM,CAAC;;AAGf,IAAA,OAAO,OAAO,GAAA;AACZ,QAAA,OAAO,0BAA0B;;AAGnC;;;;AAIG;IACH,OAAO,qBAAqB,CAC1B,QAAuB,EACvB,OAAkC,EAClC,UAAqC,EAAA;AAErC,QAAA,MAAM,UAAU,GAAG,KAAK,CAAC,qBAAqB,CAC5C,QAAQ,EACR,OAAO,EACP,UAAU,CACX;AAED,QAAA,WAAW,MAAM,KAAK,IAAI,UAAU,EAAE;;AAEpC,YAAA,IACE,KAAK,CAAC,OAAO,YAAY,cAAc;gBACtC,KAAK,CAAC,OAAmC,CAAC,iBAAiB;gBAC5D,OAAO,KAAK,CAAC,OAAO,CAAC,iBAAiB,KAAK,QAAQ,EACnD;;AAEA,gBAAA,MAAM,oBAAoB,GAAG,IAAI,CAAC,oBAAoB,CACpD,KAAK,CAAC,OAAO,CAAC,iBAAiB,CAChC;gBAED,IAAI,oBAAoB,EAAE;AACxB,oBAAA,MAAM,eAAe,GAAG,IAAI,CAAC,uBAAuB,CAClD,KAAK,CAAC,OAAO,CAAC,iBAAiB,CACL;oBAE5B,MAAM,IAAI,mBAAmB,CAAC;wBAC5B,IAAI,EAAE,KAAK,CAAC,IAAI;wBAChB,OAAO,EAAE,IAAI,cAAc,CAAC;4BAC1B,GAAG,KAAK,CAAC,OAAO;AAChB,4BAAA,iBAAiB,EAAE,eAAe;yBACnC,CAAC;wBACF,cAAc,EAAE,KAAK,CAAC,cAAc;AACrC,qBAAA,CAAC;oBACF;;;AAIJ,YAAA,MAAM,KAAK;;;AAIf;;AAEG;AACK,IAAA,oBAAoB,CAAC,GAAY,EAAA;AACvC,QAAA,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,KAAK,SAAS,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;AAChE,YAAA,OAAO,KAAK;;AAGd,QAAA,IAAI,mBAAmB,IAAI,GAAG,EAAE;AAC9B,YAAA,OAAO,IAAI;;QAGb,KAAK,MAAM,KAAK,IAAI,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE;YACtC,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,EAAE;AAC/C,gBAAA,IAAI,IAAI,CAAC,oBAAoB,CAAC,KAAK,CAAC,EAAE;AACpC,oBAAA,OAAO,IAAI;;;;AAKjB,QAAA,OAAO,KAAK;;AAGd;;AAEG;AACK,IAAA,uBAAuB,CAAC,GAAY,EAAA;QAC1C,IAAI,GAAG,KAAK,IAAI,IAAI,GAAG,KAAK,SAAS,EAAE;AACrC,YAAA,OAAO,GAAG;;AAGZ,QAAA,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;AACtB,YAAA,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;;AAG9D,QAAA,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;YAC3B,MAAM,OAAO,GAA4B,EAAE;AAC3C,YAAA,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;AAC9C,gBAAA,IAAI,GAAG,KAAK,mBAAmB,EAAE;oBAC/B,OAAO,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC;;;AAGtD,YAAA,OAAO,OAAO;;AAGhB,QAAA,OAAO,GAAG;;AAEb;;;;"}