{"version":3,"file":"MultiAgentGraph.cjs","sources":["../../../src/graphs/MultiAgentGraph.ts"],"sourcesContent":["import { z } from 'zod';\nimport { tool } from '@langchain/core/tools';\nimport { PromptTemplate } from '@langchain/core/prompts';\nimport {\n  AIMessage,\n  ToolMessage,\n  HumanMessage,\n  getBufferString,\n} from '@langchain/core/messages';\nimport {\n  END,\n  START,\n  Command,\n  StateGraph,\n  Annotation,\n  getCurrentTaskInput,\n  messagesStateReducer,\n} from '@langchain/langgraph';\nimport type { BaseMessage, AIMessageChunk } from '@langchain/core/messages';\nimport type { ToolRunnableConfig } from '@langchain/core/tools';\nimport type * as t from '@/types';\nimport { StandardGraph } from './Graph';\nimport { Constants } from '@/common';\n\n/** Pattern to extract instructions from transfer ToolMessage content */\nconst HANDOFF_INSTRUCTIONS_PATTERN = /(?:Instructions?|Context):\\s*(.+)/is;\n\n/**\n * MultiAgentGraph extends StandardGraph to support dynamic multi-agent workflows\n * with handoffs, fan-in/fan-out, and other composable patterns.\n *\n * Key behavior:\n * - Agents with ONLY handoff edges: Can dynamically route to any handoff destination\n * - Agents with ONLY direct edges: Always follow their direct edges\n * - Agents with BOTH: Use Command for exclusive routing (handoff OR direct, not both)\n *   - If handoff occurs: Only the handoff destination executes\n *   - If no handoff: Direct edges execute (potentially in parallel)\n *\n * This enables the common pattern where an agent either delegates (handoff)\n * OR continues its workflow (direct edges), but not both simultaneously.\n */\nexport class MultiAgentGraph extends StandardGraph {\n  private edges: t.GraphEdge[];\n  private startingNodes: Set<string> = new Set();\n  private directEdges: t.GraphEdge[] = [];\n  private handoffEdges: t.GraphEdge[] = [];\n  /**\n   * Map of agentId to parallel group info.\n   * Contains groupId (incrementing number reflecting execution order) for agents in parallel groups.\n   * Sequential agents (not in any parallel group) have undefined entry.\n   *\n   * Example for: researcher -> [analyst1, analyst2, analyst3] -> summarizer\n   * - researcher: undefined (sequential, order 0)\n   * - analyst1, analyst2, analyst3: { groupId: 1 } (parallel group, order 1)\n   * - summarizer: undefined (sequential, order 2)\n   */\n  private agentParallelGroups: Map<string, number> = new Map();\n\n  constructor(input: t.MultiAgentGraphInput) {\n    super(input);\n    this.edges = input.edges;\n    this.categorizeEdges();\n    this.analyzeGraph();\n    this.createHandoffTools();\n  }\n\n  /**\n   * Categorize edges into handoff and direct types\n   */\n  private categorizeEdges(): void {\n    for (const edge of this.edges) {\n      // Default behavior: edges with conditions or explicit 'handoff' type are handoff edges\n      // Edges with explicit 'direct' type or multi-destination without conditions are direct edges\n      if (edge.edgeType === 'direct') {\n        this.directEdges.push(edge);\n      } else if (edge.edgeType === 'handoff' || edge.condition != null) {\n        this.handoffEdges.push(edge);\n      } else {\n        // Default: single-to-single edges are handoff, single-to-multiple are direct\n        const destinations = Array.isArray(edge.to) ? edge.to : [edge.to];\n        const sources = Array.isArray(edge.from) ? edge.from : [edge.from];\n\n        if (sources.length === 1 && destinations.length > 1) {\n          // Fan-out pattern defaults to direct\n          this.directEdges.push(edge);\n        } else {\n          // Everything else defaults to handoff\n          this.handoffEdges.push(edge);\n        }\n      }\n    }\n  }\n\n  /**\n   * Analyze graph structure to determine starting nodes and connections\n   */\n  private analyzeGraph(): void {\n    const hasIncomingEdge = new Set<string>();\n\n    // Track all nodes that have incoming edges\n    for (const edge of this.edges) {\n      const destinations = Array.isArray(edge.to) ? edge.to : [edge.to];\n      destinations.forEach((dest) => hasIncomingEdge.add(dest));\n    }\n\n    // Starting nodes are those without incoming edges\n    for (const agentId of this.agentContexts.keys()) {\n      if (!hasIncomingEdge.has(agentId)) {\n        this.startingNodes.add(agentId);\n      }\n    }\n\n    // If no starting nodes found, use the first agent\n    if (this.startingNodes.size === 0 && this.agentContexts.size > 0) {\n      this.startingNodes.add(this.agentContexts.keys().next().value!);\n    }\n\n    // Determine if graph has parallel execution capability\n    this.computeParallelCapability();\n  }\n\n  /**\n   * Compute parallel groups by traversing the graph in execution order.\n   * Assigns incrementing group IDs that reflect the sequential order of execution.\n   *\n   * For: researcher -> [analyst1, analyst2, analyst3] -> summarizer\n   * - researcher: no group (first sequential node)\n   * - analyst1, analyst2, analyst3: groupId 1 (first parallel group)\n   * - summarizer: no group (next sequential node)\n   *\n   * This allows frontend to render in order:\n   * Row 0: researcher\n   * Row 1: [analyst1, analyst2, analyst3] (grouped)\n   * Row 2: summarizer\n   */\n  private computeParallelCapability(): void {\n    let groupCounter = 1; // Start at 1, 0 reserved for \"no group\"\n\n    // Check 1: Multiple starting nodes means parallel from the start (group 1)\n    if (this.startingNodes.size > 1) {\n      for (const agentId of this.startingNodes) {\n        this.agentParallelGroups.set(agentId, groupCounter);\n      }\n      groupCounter++;\n    }\n\n    // Check 2: Traverse direct edges in order to find fan-out patterns\n    // Build a simple execution order by following edges from starting nodes\n    const visited = new Set<string>();\n    const queue: string[] = [...this.startingNodes];\n\n    while (queue.length > 0) {\n      const current = queue.shift()!;\n      if (visited.has(current)) continue;\n      visited.add(current);\n\n      // Find direct edges from this node\n      for (const edge of this.directEdges) {\n        const sources = Array.isArray(edge.from) ? edge.from : [edge.from];\n        if (!sources.includes(current)) continue;\n\n        const destinations = Array.isArray(edge.to) ? edge.to : [edge.to];\n\n        // Fan-out: multiple destinations = parallel group\n        if (destinations.length > 1) {\n          for (const dest of destinations) {\n            // Only set if not already in a group (first group wins)\n            if (!this.agentParallelGroups.has(dest)) {\n              this.agentParallelGroups.set(dest, groupCounter);\n            }\n            if (!visited.has(dest)) {\n              queue.push(dest);\n            }\n          }\n          groupCounter++;\n        } else {\n          // Single destination - add to queue for traversal\n          for (const dest of destinations) {\n            if (!visited.has(dest)) {\n              queue.push(dest);\n            }\n          }\n        }\n      }\n\n      // Also follow handoff edges for traversal (but they don't create parallel groups)\n      for (const edge of this.handoffEdges) {\n        const sources = Array.isArray(edge.from) ? edge.from : [edge.from];\n        if (!sources.includes(current)) continue;\n\n        const destinations = Array.isArray(edge.to) ? edge.to : [edge.to];\n        for (const dest of destinations) {\n          if (!visited.has(dest)) {\n            queue.push(dest);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the parallel group ID for an agent, if any.\n   * Returns undefined if the agent is not part of a parallel group.\n   * Group IDs are incrementing numbers reflecting execution order.\n   */\n  getParallelGroupId(agentId: string): number | undefined {\n    return this.agentParallelGroups.get(agentId);\n  }\n\n  /**\n   * Override to indicate this is a multi-agent graph.\n   * Enables agentId to be included in RunStep for frontend agent labeling.\n   */\n  protected override isMultiAgentGraph(): boolean {\n    return true;\n  }\n\n  /**\n   * Override base class method to provide parallel group IDs for run steps.\n   */\n  protected override getParallelGroupIdForAgent(\n    agentId: string\n  ): number | undefined {\n    return this.agentParallelGroups.get(agentId);\n  }\n\n  /**\n   * Create handoff tools for agents based on handoff edges only\n   */\n  private createHandoffTools(): void {\n    // Group handoff edges by source agent(s)\n    const handoffsByAgent = new Map<string, t.GraphEdge[]>();\n\n    // Only process handoff edges for tool creation\n    for (const edge of this.handoffEdges) {\n      const sources = Array.isArray(edge.from) ? edge.from : [edge.from];\n      sources.forEach((source) => {\n        if (!handoffsByAgent.has(source)) {\n          handoffsByAgent.set(source, []);\n        }\n        handoffsByAgent.get(source)!.push(edge);\n      });\n    }\n\n    // Create handoff tools for each agent\n    for (const [agentId, edges] of handoffsByAgent) {\n      const agentContext = this.agentContexts.get(agentId);\n      if (!agentContext) continue;\n\n      // Create handoff tools for this agent's outgoing edges\n      const handoffTools: t.GenericTool[] = [];\n      const sourceAgentName = agentContext.name ?? agentId;\n      for (const edge of edges) {\n        handoffTools.push(\n          ...this.createHandoffToolsForEdge(edge, agentId, sourceAgentName)\n        );\n      }\n\n      // Add handoff tools to the agent's existing tools\n      if (!agentContext.tools) {\n        agentContext.tools = [];\n      }\n      agentContext.tools.push(...handoffTools);\n    }\n  }\n\n  /**\n   * Create handoff tools for an edge (handles multiple destinations)\n   * @param edge - The graph edge defining the handoff\n   * @param sourceAgentId - The ID of the agent that will perform the handoff\n   * @param sourceAgentName - The human-readable name of the source agent\n   */\n  private createHandoffToolsForEdge(\n    edge: t.GraphEdge,\n    sourceAgentId: string,\n    sourceAgentName: string\n  ): t.GenericTool[] {\n    const tools: t.GenericTool[] = [];\n    const destinations = Array.isArray(edge.to) ? edge.to : [edge.to];\n\n    /** If there's a condition, create a single conditional handoff tool */\n    if (edge.condition != null) {\n      const toolName = 'conditional_transfer';\n      const toolDescription =\n        edge.description ?? 'Conditionally transfer control based on state';\n\n      /** Check if we have a prompt for handoff input */\n      const hasHandoffInput =\n        edge.prompt != null && typeof edge.prompt === 'string';\n      const handoffInputDescription = hasHandoffInput ? edge.prompt : undefined;\n      const promptKey = edge.promptKey ?? 'instructions';\n\n      tools.push(\n        tool(\n          async (input: Record<string, unknown>, config) => {\n            const state = getCurrentTaskInput() as t.BaseGraphState;\n            const toolCallId =\n              (config as ToolRunnableConfig | undefined)?.toolCall?.id ??\n              'unknown';\n\n            /** Evaluated condition */\n            const result = edge.condition!(state);\n            let destination: string;\n\n            if (typeof result === 'boolean') {\n              /** If true, use first destination; if false, don't transfer */\n              if (!result) return null;\n              destination = destinations[0];\n            } else if (typeof result === 'string') {\n              destination = result;\n            } else {\n              /** Array of destinations - for now, use the first */\n              destination = Array.isArray(result) ? result[0] : destinations[0];\n            }\n\n            let content = `Conditionally transferred to ${destination}`;\n            if (\n              hasHandoffInput &&\n              promptKey in input &&\n              input[promptKey] != null\n            ) {\n              content += `\\n\\n${promptKey.charAt(0).toUpperCase() + promptKey.slice(1)}: ${input[promptKey]}`;\n            }\n\n            const toolMessage = new ToolMessage({\n              content,\n              name: toolName,\n              tool_call_id: toolCallId,\n              additional_kwargs: {\n                /** Store destination for programmatic access in handoff detection */\n                handoff_destination: destination,\n                /** Store source agent name for receiving agent to know who handed off */\n                handoff_source_name: sourceAgentName,\n              },\n            });\n\n            return new Command({\n              goto: destination,\n              update: { messages: state.messages.concat(toolMessage) },\n              graph: Command.PARENT,\n            });\n          },\n          {\n            name: toolName,\n            schema: hasHandoffInput\n              ? z.object({\n                [promptKey]: z\n                  .string()\n                  .optional()\n                  .describe(handoffInputDescription as string),\n              })\n              : z.object({}),\n            description: toolDescription,\n          }\n        )\n      );\n    } else {\n      /** Create individual tools for each destination */\n      for (const destination of destinations) {\n        const toolName = `${Constants.LC_TRANSFER_TO_}${destination}`;\n        const toolDescription =\n          edge.description ?? `Transfer control to agent '${destination}'`;\n\n        /** Check if we have a prompt for handoff input */\n        const hasHandoffInput =\n          edge.prompt != null && typeof edge.prompt === 'string';\n        const handoffInputDescription = hasHandoffInput\n          ? edge.prompt\n          : undefined;\n        const promptKey = edge.promptKey ?? 'instructions';\n\n        tools.push(\n          tool(\n            async (input: Record<string, unknown>, config) => {\n              const toolCallId =\n                (config as ToolRunnableConfig | undefined)?.toolCall?.id ??\n                'unknown';\n\n              let content = `Successfully transferred to ${destination}`;\n              if (\n                hasHandoffInput &&\n                promptKey in input &&\n                input[promptKey] != null\n              ) {\n                content += `\\n\\n${promptKey.charAt(0).toUpperCase() + promptKey.slice(1)}: ${input[promptKey]}`;\n              }\n\n              const toolMessage = new ToolMessage({\n                content,\n                name: toolName,\n                tool_call_id: toolCallId,\n                additional_kwargs: {\n                  /** Store source agent name for receiving agent to know who handed off */\n                  handoff_source_name: sourceAgentName,\n                },\n              });\n\n              const state = getCurrentTaskInput() as t.BaseGraphState;\n\n              /**\n               * For parallel handoff support:\n               * Build messages that include ONLY this tool call's context.\n               * This prevents errors when LLM calls multiple transfers simultaneously -\n               * each destination gets a valid AIMessage with matching tool_call and tool_result.\n               *\n               * Strategy:\n               * 1. Find the AIMessage containing this tool call\n               * 2. Create a filtered AIMessage with ONLY this tool_call\n               * 3. Include all messages before the AIMessage plus the filtered pair\n               */\n              const messages = state.messages;\n              let filteredMessages = messages;\n              let aiMessageIndex = -1;\n\n              /** Find the AIMessage containing this tool call */\n              for (let i = messages.length - 1; i >= 0; i--) {\n                const msg = messages[i];\n                if (msg.getType() === 'ai') {\n                  const aiMsg = msg as AIMessage;\n                  const hasThisCall = aiMsg.tool_calls?.some(\n                    (tc) => tc.id === toolCallId\n                  );\n                  if (hasThisCall === true) {\n                    aiMessageIndex = i;\n                    break;\n                  }\n                }\n              }\n\n              if (aiMessageIndex >= 0) {\n                const originalAiMsg = messages[aiMessageIndex] as AIMessage;\n                const thisToolCall = originalAiMsg.tool_calls?.find(\n                  (tc) => tc.id === toolCallId\n                );\n\n                if (\n                  thisToolCall != null &&\n                  (originalAiMsg.tool_calls?.length ?? 0) > 1\n                ) {\n                  /**\n                   * Multiple tool calls - create filtered AIMessage with ONLY this call.\n                   * This ensures valid message structure for parallel handoffs.\n                   */\n                  const filteredAiMsg = new AIMessage({\n                    content: originalAiMsg.content,\n                    tool_calls: [thisToolCall],\n                    id: originalAiMsg.id,\n                  });\n\n                  filteredMessages = [\n                    ...messages.slice(0, aiMessageIndex),\n                    filteredAiMsg,\n                    toolMessage,\n                  ];\n                } else {\n                  /** Single tool call - use messages as-is */\n                  filteredMessages = messages.concat(toolMessage);\n                }\n              } else {\n                /** Fallback - append tool message */\n                filteredMessages = messages.concat(toolMessage);\n              }\n\n              return new Command({\n                goto: destination,\n                update: { messages: filteredMessages },\n                graph: Command.PARENT,\n              });\n            },\n            {\n              name: toolName,\n              schema: hasHandoffInput\n                ? z.object({\n                  [promptKey]: z\n                    .string()\n                    .optional()\n                    .describe(handoffInputDescription as string),\n                })\n                : z.object({}),\n              description: toolDescription,\n            }\n          )\n        );\n      }\n    }\n\n    return tools;\n  }\n\n  /**\n   * Create a complete agent subgraph (similar to createReactAgent)\n   */\n  private createAgentSubgraph(agentId: string): t.CompiledAgentWorfklow {\n    /** This is essentially the same as `createAgentNode` from `StandardGraph` */\n    return this.createAgentNode(agentId);\n  }\n\n  /**\n   * Detects if the current agent is receiving a handoff and processes the messages accordingly.\n   * Returns filtered messages with the transfer tool call/message removed, plus any instructions,\n   * source agent, and parallel sibling information extracted from the transfer.\n   *\n   * Supports both single handoffs (last message is the transfer) and parallel handoffs\n   * (multiple transfer ToolMessages, need to find the one targeting this agent).\n   *\n   * @param messages - Current state messages\n   * @param agentId - The agent ID to check for handoff reception\n   * @returns Object with filtered messages, extracted instructions, source agent, and parallel siblings\n   */\n  private processHandoffReception(\n    messages: BaseMessage[],\n    agentId: string\n  ): {\n    filteredMessages: BaseMessage[];\n    instructions: string | null;\n    sourceAgentName: string | null;\n    parallelSiblings: string[];\n  } | null {\n    if (messages.length === 0) return null;\n\n    /**\n     * Search for a transfer ToolMessage targeting this agent.\n     * For parallel handoffs, multiple transfer messages may exist - find ours.\n     * Search backwards from the end to find the most recent transfer to this agent.\n     */\n    let toolMessage: ToolMessage | null = null;\n    let toolMessageIndex = -1;\n\n    for (let i = messages.length - 1; i >= 0; i--) {\n      const msg = messages[i];\n      if (msg.getType() !== 'tool') continue;\n\n      const candidateMsg = msg as ToolMessage;\n      const toolName = candidateMsg.name;\n\n      if (typeof toolName !== 'string') continue;\n\n      /** Check for standard transfer pattern */\n      const isTransferMessage = toolName.startsWith(Constants.LC_TRANSFER_TO_);\n      const isConditionalTransfer = toolName === 'conditional_transfer';\n\n      if (!isTransferMessage && !isConditionalTransfer) continue;\n\n      /** Extract destination from tool name or additional_kwargs */\n      let destinationAgent: string | null = null;\n\n      if (isTransferMessage) {\n        destinationAgent = toolName.replace(Constants.LC_TRANSFER_TO_, '');\n      } else if (isConditionalTransfer) {\n        const handoffDest = candidateMsg.additional_kwargs.handoff_destination;\n        destinationAgent = typeof handoffDest === 'string' ? handoffDest : null;\n      }\n\n      /** Check if this transfer targets our agent */\n      if (destinationAgent === agentId) {\n        toolMessage = candidateMsg;\n        toolMessageIndex = i;\n        break;\n      }\n    }\n\n    /** No transfer targeting this agent found */\n    if (toolMessage === null || toolMessageIndex < 0) return null;\n\n    /** Extract instructions from the ToolMessage content */\n    const contentStr =\n      typeof toolMessage.content === 'string'\n        ? toolMessage.content\n        : JSON.stringify(toolMessage.content);\n\n    const instructionsMatch = contentStr.match(HANDOFF_INSTRUCTIONS_PATTERN);\n    const instructions = instructionsMatch?.[1]?.trim() ?? null;\n\n    /** Extract source agent name from additional_kwargs */\n    const handoffSourceName = toolMessage.additional_kwargs.handoff_source_name;\n    const sourceAgentName =\n      typeof handoffSourceName === 'string' ? handoffSourceName : null;\n\n    /** Extract parallel siblings (set by ToolNode for parallel handoffs) */\n    const rawSiblings = toolMessage.additional_kwargs.handoff_parallel_siblings;\n    const siblingIds: string[] = Array.isArray(rawSiblings)\n      ? rawSiblings.filter((s): s is string => typeof s === 'string')\n      : [];\n    /** Convert IDs to display names */\n    const parallelSiblings = siblingIds.map((id) => {\n      const ctx = this.agentContexts.get(id);\n      return ctx?.name ?? id;\n    });\n\n    /** Get the tool_call_id to find and filter the AI message's tool call */\n    const toolCallId = toolMessage.tool_call_id;\n\n    /**\n     * Collect all transfer tool_call_ids to filter out.\n     * For parallel handoffs, we filter ALL transfer messages (not just ours)\n     * to give the receiving agent a clean context without handoff noise.\n     */\n    const transferToolCallIds = new Set<string>([toolCallId]);\n    for (const msg of messages) {\n      if (msg.getType() !== 'tool') continue;\n      const tm = msg as ToolMessage;\n      const tName = tm.name;\n      if (typeof tName !== 'string') continue;\n      if (\n        tName.startsWith(Constants.LC_TRANSFER_TO_) ||\n        tName === 'conditional_transfer'\n      ) {\n        transferToolCallIds.add(tm.tool_call_id);\n      }\n    }\n\n    /** Filter out all transfer messages */\n    const filteredMessages: BaseMessage[] = [];\n\n    for (let i = 0; i < messages.length; i++) {\n      const msg = messages[i];\n      const msgType = msg.getType();\n\n      /** Skip transfer ToolMessages */\n      if (msgType === 'tool') {\n        const tm = msg as ToolMessage;\n        if (transferToolCallIds.has(tm.tool_call_id)) {\n          continue;\n        }\n      }\n\n      if (msgType === 'ai') {\n        /** Check if this AI message contains any transfer tool calls */\n        const aiMsg = msg as AIMessage | AIMessageChunk;\n        const toolCalls = aiMsg.tool_calls;\n\n        if (toolCalls && toolCalls.length > 0) {\n          /** Filter out all transfer tool calls */\n          const remainingToolCalls = toolCalls.filter(\n            (tc) => tc.id == null || !transferToolCallIds.has(tc.id)\n          );\n\n          const hasTransferCalls = remainingToolCalls.length < toolCalls.length;\n\n          if (hasTransferCalls) {\n            if (\n              remainingToolCalls.length > 0 ||\n              (typeof aiMsg.content === 'string' && aiMsg.content.trim())\n            ) {\n              /** Keep the message but without transfer tool calls */\n              const filteredAiMsg = new AIMessage({\n                content: aiMsg.content,\n                tool_calls: remainingToolCalls,\n                id: aiMsg.id,\n              });\n              filteredMessages.push(filteredAiMsg);\n            }\n            /** If no remaining content or tool calls, skip this message entirely */\n            continue;\n          }\n        }\n      }\n\n      /** Keep all other messages */\n      filteredMessages.push(msg);\n    }\n\n    return {\n      filteredMessages,\n      instructions,\n      sourceAgentName,\n      parallelSiblings,\n    };\n  }\n\n  /**\n   * Create the multi-agent workflow with dynamic handoffs\n   */\n  override createWorkflow(): t.CompiledMultiAgentWorkflow {\n    const StateAnnotation = Annotation.Root({\n      messages: Annotation<BaseMessage[]>({\n        reducer: (a, b) => {\n          if (!a.length) {\n            this.startIndex = a.length + b.length;\n          }\n          const result = messagesStateReducer(a, b);\n          this.messages = result;\n          return result;\n        },\n        default: () => [],\n      }),\n      /** Channel for passing filtered messages to agents when excludeResults is true */\n      agentMessages: Annotation<BaseMessage[]>({\n        /** Replaces state entirely */\n        reducer: (a, b) => b,\n        default: () => [],\n      }),\n    });\n\n    const builder = new StateGraph(StateAnnotation);\n\n    // Add all agents as complete subgraphs\n    for (const [agentId] of this.agentContexts) {\n      // Get all possible destinations for this agent\n      const handoffDestinations = new Set<string>();\n      const directDestinations = new Set<string>();\n\n      // Check handoff edges for destinations\n      for (const edge of this.handoffEdges) {\n        const sources = Array.isArray(edge.from) ? edge.from : [edge.from];\n        if (sources.includes(agentId) === true) {\n          const dests = Array.isArray(edge.to) ? edge.to : [edge.to];\n          dests.forEach((dest) => handoffDestinations.add(dest));\n        }\n      }\n\n      // Check direct edges for destinations\n      for (const edge of this.directEdges) {\n        const sources = Array.isArray(edge.from) ? edge.from : [edge.from];\n        if (sources.includes(agentId) === true) {\n          const dests = Array.isArray(edge.to) ? edge.to : [edge.to];\n          dests.forEach((dest) => directDestinations.add(dest));\n        }\n      }\n\n      /** Check if this agent has BOTH handoff and direct edges */\n      const hasHandoffEdges = handoffDestinations.size > 0;\n      const hasDirectEdges = directDestinations.size > 0;\n      const needsCommandRouting = hasHandoffEdges && hasDirectEdges;\n\n      /** Collect all possible destinations for this agent */\n      const allDestinations = new Set([\n        ...handoffDestinations,\n        ...directDestinations,\n      ]);\n      if (handoffDestinations.size > 0 || directDestinations.size === 0) {\n        allDestinations.add(END);\n      }\n\n      /** Agent subgraph (includes agent + tools) */\n      const agentSubgraph = this.createAgentSubgraph(agentId);\n\n      /** Wrapper function that handles agentMessages channel, handoff reception, and conditional routing */\n      const agentWrapper = async (\n        state: t.MultiAgentGraphState\n      ): Promise<t.MultiAgentGraphState | Command> => {\n        let result: t.MultiAgentGraphState;\n\n        /**\n         * Check if this agent is receiving a handoff.\n         * If so, filter out the transfer messages and inject instructions as preamble.\n         * This prevents the receiving agent from seeing the transfer as \"completed work\"\n         * and prematurely producing an end token.\n         */\n        const handoffContext = this.processHandoffReception(\n          state.messages,\n          agentId\n        );\n\n        if (handoffContext !== null) {\n          const {\n            filteredMessages,\n            instructions,\n            sourceAgentName,\n            parallelSiblings,\n          } = handoffContext;\n\n          /**\n           * Set handoff context on the receiving agent.\n           * Uses pre-computed graph position for depth and parallel info.\n           */\n          const agentContext = this.agentContexts.get(agentId);\n          if (\n            agentContext &&\n            sourceAgentName != null &&\n            sourceAgentName !== ''\n          ) {\n            agentContext.setHandoffContext(sourceAgentName, parallelSiblings);\n          }\n\n          /** Build messages for the receiving agent */\n          let messagesForAgent = filteredMessages;\n\n          /** If there are instructions, inject them as a HumanMessage to ground the agent */\n          const hasInstructions = instructions !== null && instructions !== '';\n          if (hasInstructions) {\n            messagesForAgent = [\n              ...filteredMessages,\n              new HumanMessage(instructions),\n            ];\n          }\n\n          /** Update token map if we have a token counter */\n          if (agentContext?.tokenCounter && hasInstructions) {\n            const freshTokenMap: Record<string, number> = {};\n            for (\n              let i = 0;\n              i < Math.min(filteredMessages.length, this.startIndex);\n              i++\n            ) {\n              const tokenCount = agentContext.indexTokenCountMap[i];\n              if (tokenCount !== undefined) {\n                freshTokenMap[i] = tokenCount;\n              }\n            }\n            /** Add tokens for the instructions message */\n            const instructionsMsg = new HumanMessage(instructions);\n            freshTokenMap[messagesForAgent.length - 1] =\n              agentContext.tokenCounter(instructionsMsg);\n            agentContext.updateTokenMapWithInstructions(freshTokenMap);\n          }\n\n          const transformedState: t.MultiAgentGraphState = {\n            ...state,\n            messages: messagesForAgent,\n          };\n          result = await agentSubgraph.invoke(transformedState);\n          result = {\n            ...result,\n            agentMessages: [],\n          };\n        } else if (\n          state.agentMessages != null &&\n          state.agentMessages.length > 0\n        ) {\n          /**\n           * When using agentMessages (excludeResults=true), we need to update\n           * the token map to account for the new prompt message\n           */\n          const agentContext = this.agentContexts.get(agentId);\n          if (agentContext && agentContext.tokenCounter) {\n            /** The agentMessages contains:\n             * 1. Filtered messages (0 to startIndex) - already have token counts\n             * 2. New prompt message - needs token counting\n             */\n            const freshTokenMap: Record<string, number> = {};\n\n            /** Copy existing token counts for filtered messages (0 to startIndex) */\n            for (let i = 0; i < this.startIndex; i++) {\n              const tokenCount = agentContext.indexTokenCountMap[i];\n              if (tokenCount !== undefined) {\n                freshTokenMap[i] = tokenCount;\n              }\n            }\n\n            /** Calculate tokens only for the new prompt message (last message) */\n            const promptMessageIndex = state.agentMessages.length - 1;\n            if (promptMessageIndex >= this.startIndex) {\n              const promptMessage = state.agentMessages[promptMessageIndex];\n              freshTokenMap[promptMessageIndex] =\n                agentContext.tokenCounter(promptMessage);\n            }\n\n            /** Update the agent's token map with instructions added */\n            agentContext.updateTokenMapWithInstructions(freshTokenMap);\n          }\n\n          /** Temporary state with messages replaced by `agentMessages` */\n          const transformedState: t.MultiAgentGraphState = {\n            ...state,\n            messages: state.agentMessages,\n          };\n          result = await agentSubgraph.invoke(transformedState);\n          result = {\n            ...result,\n            /** Clear agentMessages for next agent */\n            agentMessages: [],\n          };\n        } else {\n          result = await agentSubgraph.invoke(state);\n        }\n\n        /** If agent has both handoff and direct edges, use Command for exclusive routing */\n        if (needsCommandRouting) {\n          /** Check if a handoff occurred */\n          const lastMessage = result.messages[\n            result.messages.length - 1\n          ] as BaseMessage | null;\n          if (\n            lastMessage != null &&\n            lastMessage.getType() === 'tool' &&\n            typeof lastMessage.name === 'string' &&\n            lastMessage.name.startsWith(Constants.LC_TRANSFER_TO_)\n          ) {\n            /** Handoff occurred - extract destination and navigate there exclusively */\n            const handoffDest = lastMessage.name.replace(\n              Constants.LC_TRANSFER_TO_,\n              ''\n            );\n            return new Command({\n              update: result,\n              goto: handoffDest,\n            });\n          } else {\n            /** No handoff - proceed with direct edges */\n            const directDests = Array.from(directDestinations);\n            if (directDests.length === 1) {\n              return new Command({\n                update: result,\n                goto: directDests[0],\n              });\n            } else if (directDests.length > 1) {\n              /** Multiple direct destinations - they'll run in parallel */\n              return new Command({\n                update: result,\n                goto: directDests,\n              });\n            }\n          }\n        }\n\n        /** No special routing needed - return state normally */\n        return result;\n      };\n\n      /** Wrapped agent as a node with its possible destinations */\n      builder.addNode(agentId, agentWrapper, {\n        ends: Array.from(allDestinations),\n      });\n    }\n\n    // Add starting edges for all starting nodes\n    for (const startNode of this.startingNodes) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      /** @ts-ignore */\n      builder.addEdge(START, startNode);\n    }\n\n    /**\n     * Add direct edges for automatic transitions\n     * Group edges by destination to handle fan-in scenarios\n     */\n    const edgesByDestination = new Map<string, t.GraphEdge[]>();\n\n    for (const edge of this.directEdges) {\n      const destinations = Array.isArray(edge.to) ? edge.to : [edge.to];\n      for (const destination of destinations) {\n        if (!edgesByDestination.has(destination)) {\n          edgesByDestination.set(destination, []);\n        }\n        edgesByDestination.get(destination)!.push(edge);\n      }\n    }\n\n    for (const [destination, edges] of edgesByDestination) {\n      /** Checks if this is a fan-in scenario with prompt instructions */\n      const edgesWithPrompt = edges.filter(\n        (edge) => edge.prompt != null && edge.prompt !== ''\n      );\n\n      if (edgesWithPrompt.length > 0) {\n        /**\n         * Single wrapper node for destination (Fan-in with prompt)\n         */\n        const wrapperNodeId = `fan_in_${destination}_prompt`;\n        /**\n         * First edge's `prompt`\n         * (they should all be the same for fan-in)\n         */\n        const prompt = edgesWithPrompt[0].prompt;\n        /**\n         * First edge's `excludeResults` flag\n         * (they should all be the same for fan-in)\n         */\n        const excludeResults = edgesWithPrompt[0].excludeResults;\n\n        builder.addNode(wrapperNodeId, async (state: t.BaseGraphState) => {\n          let promptText: string | undefined;\n          let effectiveExcludeResults = excludeResults;\n\n          if (typeof prompt === 'function') {\n            promptText = await prompt(state.messages, this.startIndex);\n          } else if (prompt != null) {\n            if (prompt.includes('{results}')) {\n              const resultsMessages = state.messages.slice(this.startIndex);\n              const resultsString = getBufferString(resultsMessages);\n              const promptTemplate = PromptTemplate.fromTemplate(prompt);\n              const result = await promptTemplate.invoke({\n                results: resultsString,\n              });\n              promptText = result.value;\n              effectiveExcludeResults =\n                excludeResults !== false && promptText !== '';\n            } else {\n              promptText = prompt;\n            }\n          }\n\n          if (promptText != null && promptText !== '') {\n            if (\n              effectiveExcludeResults == null ||\n              effectiveExcludeResults === false\n            ) {\n              return {\n                messages: [new HumanMessage(promptText)],\n              };\n            }\n\n            /** When `excludeResults` is true, use agentMessages channel\n             * to pass filtered messages + prompt to the destination agent\n             */\n            const filteredMessages = state.messages.slice(0, this.startIndex);\n            return {\n              messages: [new HumanMessage(promptText)],\n              agentMessages: messagesStateReducer(filteredMessages, [\n                new HumanMessage(promptText),\n              ]),\n            };\n          }\n\n          /** No prompt needed, return empty update */\n          return {};\n        });\n\n        /** Add edges from all sources to the wrapper, then wrapper to destination */\n        for (const edge of edges) {\n          const sources = Array.isArray(edge.from) ? edge.from : [edge.from];\n          for (const source of sources) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            /** @ts-ignore */\n            builder.addEdge(source, wrapperNodeId);\n          }\n        }\n\n        /** Single edge from wrapper to destination */\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        /** @ts-ignore */\n        builder.addEdge(wrapperNodeId, destination);\n      } else {\n        /** No prompt instructions, add direct edges (skip if source uses Command routing) */\n        for (const edge of edges) {\n          const sources = Array.isArray(edge.from) ? edge.from : [edge.from];\n          for (const source of sources) {\n            /** Check if this source node has both handoff and direct edges */\n            const sourceHandoffEdges = this.handoffEdges.filter((e) => {\n              const eSources = Array.isArray(e.from) ? e.from : [e.from];\n              return eSources.includes(source);\n            });\n            const sourceDirectEdges = this.directEdges.filter((e) => {\n              const eSources = Array.isArray(e.from) ? e.from : [e.from];\n              return eSources.includes(source);\n            });\n\n            /** Skip adding edge if source uses Command routing (has both types) */\n            if (sourceHandoffEdges.length > 0 && sourceDirectEdges.length > 0) {\n              continue;\n            }\n\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            /** @ts-ignore */\n            builder.addEdge(source, destination);\n          }\n        }\n      }\n    }\n\n    return builder.compile(this.compileOptions as unknown as never);\n  }\n}\n"],"names":["StandardGraph","tools","tool","getCurrentTaskInput","ToolMessage","Command","z","Constants","messages","AIMessage","Annotation","messagesStateReducer","StateGraph","END","HumanMessage","START","getBufferString","PromptTemplate"],"mappings":"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"}