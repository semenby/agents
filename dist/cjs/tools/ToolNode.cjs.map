{"version":3,"file":"ToolNode.cjs","sources":["../../../src/tools/ToolNode.ts"],"sourcesContent":["import { ToolCall } from '@langchain/core/messages/tool';\nimport {\n  ToolMessage,\n  isAIMessage,\n  isBaseMessage,\n} from '@langchain/core/messages';\nimport {\n  END,\n  Send,\n  Command,\n  isCommand,\n  isGraphInterrupt,\n  MessagesAnnotation,\n} from '@langchain/langgraph';\nimport type {\n  RunnableConfig,\n  RunnableToolLike,\n} from '@langchain/core/runnables';\nimport type { BaseMessage, AIMessage } from '@langchain/core/messages';\nimport type { StructuredToolInterface } from '@langchain/core/tools';\nimport type * as t from '@/types';\nimport { RunnableCallable } from '@/utils';\nimport { Constants } from '@/common';\n\n/**\n * Helper to check if a value is a Send object\n */\nfunction isSend(value: unknown): value is Send {\n  return value instanceof Send;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class ToolNode<T = any> extends RunnableCallable<T, T> {\n  private toolMap: Map<string, StructuredToolInterface | RunnableToolLike>;\n  private loadRuntimeTools?: t.ToolRefGenerator;\n  handleToolErrors = true;\n  trace = false;\n  toolCallStepIds?: Map<string, string>;\n  errorHandler?: t.ToolNodeConstructorParams['errorHandler'];\n  private toolUsageCount: Map<string, number>;\n  /** Tool registry for filtering (lazy computation of programmatic maps) */\n  private toolRegistry?: t.LCToolRegistry;\n  /** Cached programmatic tools (computed once on first PTC call) */\n  private programmaticCache?: t.ProgrammaticCache;\n  /** Reference to Graph's sessions map for automatic session injection */\n  private sessions?: t.ToolSessionMap;\n\n  constructor({\n    tools,\n    toolMap,\n    name,\n    tags,\n    errorHandler,\n    toolCallStepIds,\n    handleToolErrors,\n    loadRuntimeTools,\n    toolRegistry,\n    sessions,\n  }: t.ToolNodeConstructorParams) {\n    super({ name, tags, func: (input, config) => this.run(input, config) });\n    this.toolMap = toolMap ?? new Map(tools.map((tool) => [tool.name, tool]));\n    this.toolCallStepIds = toolCallStepIds;\n    this.handleToolErrors = handleToolErrors ?? this.handleToolErrors;\n    this.loadRuntimeTools = loadRuntimeTools;\n    this.errorHandler = errorHandler;\n    this.toolUsageCount = new Map<string, number>();\n    this.toolRegistry = toolRegistry;\n    this.sessions = sessions;\n  }\n\n  /**\n   * Returns cached programmatic tools, computing once on first access.\n   * Single iteration builds both toolMap and toolDefs simultaneously.\n   */\n  private getProgrammaticTools(): { toolMap: t.ToolMap; toolDefs: t.LCTool[] } {\n    if (this.programmaticCache) return this.programmaticCache;\n\n    const toolMap: t.ToolMap = new Map();\n    const toolDefs: t.LCTool[] = [];\n\n    if (this.toolRegistry) {\n      for (const [name, toolDef] of this.toolRegistry) {\n        if (\n          (toolDef.allowed_callers ?? ['direct']).includes('code_execution')\n        ) {\n          toolDefs.push(toolDef);\n          const tool = this.toolMap.get(name);\n          if (tool) toolMap.set(name, tool);\n        }\n      }\n    }\n\n    this.programmaticCache = { toolMap, toolDefs };\n    return this.programmaticCache;\n  }\n\n  /**\n   * Returns a snapshot of the current tool usage counts.\n   * @returns A ReadonlyMap where keys are tool names and values are their usage counts.\n   */\n  public getToolUsageCounts(): ReadonlyMap<string, number> {\n    return new Map(this.toolUsageCount); // Return a copy\n  }\n\n  /**\n   * Runs a single tool call with error handling\n   */\n  protected async runTool(\n    call: ToolCall,\n    config: RunnableConfig\n  ): Promise<BaseMessage | Command> {\n    const tool = this.toolMap.get(call.name);\n    try {\n      if (tool === undefined) {\n        throw new Error(`Tool \"${call.name}\" not found.`);\n      }\n      const turn = this.toolUsageCount.get(call.name) ?? 0;\n      this.toolUsageCount.set(call.name, turn + 1);\n      const args = call.args;\n      const stepId = this.toolCallStepIds?.get(call.id!);\n\n      // Build invoke params - LangChain extracts non-schema fields to config.toolCall\n      let invokeParams: Record<string, unknown> = {\n        ...call,\n        args,\n        type: 'tool_call',\n        stepId,\n        turn,\n      };\n\n      // Inject runtime data for special tools (becomes available at config.toolCall)\n      if (call.name === Constants.PROGRAMMATIC_TOOL_CALLING) {\n        const { toolMap, toolDefs } = this.getProgrammaticTools();\n        invokeParams = {\n          ...invokeParams,\n          toolMap,\n          toolDefs,\n        };\n      } else if (call.name === Constants.TOOL_SEARCH) {\n        invokeParams = {\n          ...invokeParams,\n          toolRegistry: this.toolRegistry,\n        };\n      }\n\n      /**\n       * Inject session context for code execution tools when available.\n       * Each file uses its own session_id (supporting multi-session file tracking).\n       * Both session_id and _injected_files are injected directly to invokeParams\n       * (not inside args) so they bypass Zod schema validation and reach config.toolCall.\n       */\n      if (\n        call.name === Constants.EXECUTE_CODE ||\n        call.name === Constants.PROGRAMMATIC_TOOL_CALLING\n      ) {\n        const codeSession = this.sessions?.get(Constants.EXECUTE_CODE) as\n          | t.CodeSessionContext\n          | undefined;\n        if (codeSession?.files != null && codeSession.files.length > 0) {\n          /**\n           * Convert tracked files to CodeEnvFile format for the API.\n           * Each file uses its own session_id (set when file was created).\n           * This supports files from multiple parallel/sequential executions.\n           */\n          const fileRefs: t.CodeEnvFile[] = codeSession.files.map((file) => ({\n            session_id: file.session_id ?? codeSession.session_id,\n            id: file.id,\n            name: file.name,\n          }));\n          /** Inject latest session_id and files - bypasses Zod, reaches config.toolCall */\n          invokeParams = {\n            ...invokeParams,\n            session_id: codeSession.session_id,\n            _injected_files: fileRefs,\n          };\n        }\n      }\n\n      const output = await tool.invoke(invokeParams, config);\n      if (\n        (isBaseMessage(output) && output._getType() === 'tool') ||\n        isCommand(output)\n      ) {\n        return output;\n      } else {\n        return new ToolMessage({\n          status: 'success',\n          name: tool.name,\n          content: typeof output === 'string' ? output : JSON.stringify(output),\n          tool_call_id: call.id!,\n        });\n      }\n    } catch (_e: unknown) {\n      const e = _e as Error;\n      if (!this.handleToolErrors) {\n        throw e;\n      }\n      if (isGraphInterrupt(e)) {\n        throw e;\n      }\n      if (this.errorHandler) {\n        try {\n          await this.errorHandler(\n            {\n              error: e,\n              id: call.id!,\n              name: call.name,\n              input: call.args,\n            },\n            config.metadata\n          );\n        } catch (handlerError) {\n          // eslint-disable-next-line no-console\n          console.error('Error in errorHandler:', {\n            toolName: call.name,\n            toolCallId: call.id,\n            toolArgs: call.args,\n            stepId: this.toolCallStepIds?.get(call.id!),\n            turn: this.toolUsageCount.get(call.name),\n            originalError: {\n              message: e.message,\n              stack: e.stack ?? undefined,\n            },\n            handlerError:\n              handlerError instanceof Error\n                ? {\n                  message: handlerError.message,\n                  stack: handlerError.stack ?? undefined,\n                }\n                : {\n                  message: String(handlerError),\n                  stack: undefined,\n                },\n          });\n        }\n      }\n      return new ToolMessage({\n        status: 'error',\n        content: `Error: ${e.message}\\n Please fix your mistakes.`,\n        name: call.name,\n        tool_call_id: call.id ?? '',\n      });\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected async run(input: any, config: RunnableConfig): Promise<T> {\n    let outputs: (BaseMessage | Command)[];\n\n    if (this.isSendInput(input)) {\n      outputs = [await this.runTool(input.lg_tool_call, config)];\n    } else {\n      let messages: BaseMessage[];\n      if (Array.isArray(input)) {\n        messages = input;\n      } else if (this.isMessagesState(input)) {\n        messages = input.messages;\n      } else {\n        throw new Error(\n          'ToolNode only accepts BaseMessage[] or { messages: BaseMessage[] } as input.'\n        );\n      }\n\n      const toolMessageIds: Set<string> = new Set(\n        messages\n          .filter((msg) => msg._getType() === 'tool')\n          .map((msg) => (msg as ToolMessage).tool_call_id)\n      );\n\n      let aiMessage: AIMessage | undefined;\n      for (let i = messages.length - 1; i >= 0; i--) {\n        const message = messages[i];\n        if (isAIMessage(message)) {\n          aiMessage = message;\n          break;\n        }\n      }\n\n      if (aiMessage == null || !isAIMessage(aiMessage)) {\n        throw new Error('ToolNode only accepts AIMessages as input.');\n      }\n\n      if (this.loadRuntimeTools) {\n        const { tools, toolMap } = this.loadRuntimeTools(\n          aiMessage.tool_calls ?? []\n        );\n        this.toolMap =\n          toolMap ?? new Map(tools.map((tool) => [tool.name, tool]));\n        this.programmaticCache = undefined; // Invalidate cache on toolMap change\n      }\n\n      outputs = await Promise.all(\n        aiMessage.tool_calls\n          ?.filter((call) => {\n            /**\n             * Filter out:\n             * 1. Already processed tool calls (present in toolMessageIds)\n             * 2. Server tool calls (e.g., web_search with IDs starting with 'srvtoolu_')\n             *    which are executed by the provider's API and don't require invocation\n             */\n            return (\n              (call.id == null || !toolMessageIds.has(call.id)) &&\n              !(call.id?.startsWith('srvtoolu_') ?? false)\n            );\n          })\n          .map((call) => this.runTool(call, config)) ?? []\n      );\n    }\n\n    if (!outputs.some(isCommand)) {\n      return (Array.isArray(input) ? outputs : { messages: outputs }) as T;\n    }\n\n    const combinedOutputs: (\n      | { messages: BaseMessage[] }\n      | BaseMessage[]\n      | Command\n    )[] = [];\n    let parentCommand: Command | null = null;\n\n    /**\n     * Collect handoff commands (Commands with string goto and Command.PARENT)\n     * for potential parallel handoff aggregation\n     */\n    const handoffCommands: Command[] = [];\n    const nonCommandOutputs: BaseMessage[] = [];\n\n    for (const output of outputs) {\n      if (isCommand(output)) {\n        if (\n          output.graph === Command.PARENT &&\n          Array.isArray(output.goto) &&\n          output.goto.every((send): send is Send => isSend(send))\n        ) {\n          /** Aggregate Send-based commands */\n          if (parentCommand) {\n            (parentCommand.goto as Send[]).push(...(output.goto as Send[]));\n          } else {\n            parentCommand = new Command({\n              graph: Command.PARENT,\n              goto: output.goto,\n            });\n          }\n        } else if (output.graph === Command.PARENT) {\n          /**\n           * Handoff Command with destination.\n           * Handle both string ('agent') and array (['agent']) formats.\n           * Collect for potential parallel aggregation.\n           */\n          const goto = output.goto;\n          const isSingleStringDest = typeof goto === 'string';\n          const isSingleArrayDest =\n            Array.isArray(goto) &&\n            goto.length === 1 &&\n            typeof goto[0] === 'string';\n\n          if (isSingleStringDest || isSingleArrayDest) {\n            handoffCommands.push(output);\n          } else {\n            /** Multi-destination or other command - pass through */\n            combinedOutputs.push(output);\n          }\n        } else {\n          /** Other commands - pass through */\n          combinedOutputs.push(output);\n        }\n      } else {\n        nonCommandOutputs.push(output);\n        combinedOutputs.push(\n          Array.isArray(input) ? [output] : { messages: [output] }\n        );\n      }\n    }\n\n    /**\n     * Handle handoff commands - convert to Send objects for parallel execution\n     * when multiple handoffs are requested\n     */\n    if (handoffCommands.length > 1) {\n      /**\n       * Multiple parallel handoffs - convert to Send objects.\n       * Each Send carries its own state with the appropriate messages.\n       * This enables LLM-initiated parallel execution when calling multiple\n       * transfer tools simultaneously.\n       */\n\n      /** Collect all destinations for sibling tracking */\n      const allDestinations = handoffCommands.map((cmd) => {\n        const goto = cmd.goto;\n        return typeof goto === 'string' ? goto : (goto as string[])[0];\n      });\n\n      const sends = handoffCommands.map((cmd, idx) => {\n        const destination = allDestinations[idx];\n        /** Get siblings (other destinations, not this one) */\n        const siblings = allDestinations.filter((d) => d !== destination);\n\n        /** Add siblings to ToolMessage additional_kwargs */\n        const update = cmd.update as { messages?: BaseMessage[] } | undefined;\n        if (update && update.messages) {\n          for (const msg of update.messages) {\n            if (msg.getType() === 'tool') {\n              (msg as ToolMessage).additional_kwargs.handoff_parallel_siblings =\n                siblings;\n            }\n          }\n        }\n\n        return new Send(destination, cmd.update);\n      });\n\n      const parallelCommand = new Command({\n        graph: Command.PARENT,\n        goto: sends,\n      });\n      combinedOutputs.push(parallelCommand);\n    } else if (handoffCommands.length === 1) {\n      /** Single handoff - pass through as-is */\n      combinedOutputs.push(handoffCommands[0]);\n    }\n\n    if (parentCommand) {\n      combinedOutputs.push(parentCommand);\n    }\n\n    return combinedOutputs as T;\n  }\n\n  private isSendInput(input: unknown): input is { lg_tool_call: ToolCall } {\n    return (\n      typeof input === 'object' && input != null && 'lg_tool_call' in input\n    );\n  }\n\n  private isMessagesState(\n    input: unknown\n  ): input is { messages: BaseMessage[] } {\n    return (\n      typeof input === 'object' &&\n      input != null &&\n      'messages' in input &&\n      Array.isArray((input as { messages: unknown }).messages) &&\n      (input as { messages: unknown[] }).messages.every(isBaseMessage)\n    );\n  }\n}\n\nfunction areToolCallsInvoked(\n  message: AIMessage,\n  invokedToolIds?: Set<string>\n): boolean {\n  if (!invokedToolIds || invokedToolIds.size === 0) return false;\n  return (\n    message.tool_calls?.every(\n      (toolCall) => toolCall.id != null && invokedToolIds.has(toolCall.id)\n    ) ?? false\n  );\n}\n\nexport function toolsCondition<T extends string>(\n  state: BaseMessage[] | typeof MessagesAnnotation.State,\n  toolNode: T,\n  invokedToolIds?: Set<string>\n): T | typeof END {\n  const message: AIMessage = Array.isArray(state)\n    ? state[state.length - 1]\n    : state.messages[state.messages.length - 1];\n\n  if (\n    'tool_calls' in message &&\n    (message.tool_calls?.length ?? 0) > 0 &&\n    !areToolCallsInvoked(message, invokedToolIds)\n  ) {\n    return toolNode;\n  } else {\n    return END;\n  }\n}\n"],"names":["Send","RunnableCallable","Constants","isBaseMessage","isCommand","ToolMessage","isGraphInterrupt","messages","isAIMessage","Command","END"],"mappings":"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"}