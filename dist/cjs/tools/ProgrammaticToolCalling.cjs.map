{"version":3,"file":"ProgrammaticToolCalling.cjs","sources":["../../../src/tools/ProgrammaticToolCalling.ts"],"sourcesContent":["// src/tools/ProgrammaticToolCalling.ts\nimport { z } from 'zod';\nimport { config } from 'dotenv';\nimport fetch, { RequestInit } from 'node-fetch';\nimport { HttpsProxyAgent } from 'https-proxy-agent';\nimport { getEnvironmentVariable } from '@langchain/core/utils/env';\nimport { tool, DynamicStructuredTool } from '@langchain/core/tools';\nimport type { ToolCall } from '@langchain/core/messages/tool';\nimport type * as t from '@/types';\nimport { imageExtRegex, getCodeBaseURL } from './CodeExecutor';\nimport { EnvVar, Constants } from '@/common';\n\nconfig();\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst imageMessage = 'Image is already displayed to the user';\nconst otherMessage = 'File is already downloaded by the user';\nconst accessMessage =\n  'Note: Files from previous executions are automatically available and can be modified.';\nconst emptyOutputMessage =\n  'stdout: Empty. Ensure you\\'re writing output explicitly.\\n';\n\n/** Default max round-trips to prevent infinite loops */\nconst DEFAULT_MAX_ROUND_TRIPS = 20;\n\n/** Default execution timeout in milliseconds */\nconst DEFAULT_TIMEOUT = 60000;\n\n// ============================================================================\n// Schema\n// ============================================================================\n\nconst ProgrammaticToolCallingSchema = z.object({\n  code: z\n    .string()\n    .min(1)\n    .describe(\n      `Python code that calls tools programmatically. Tools are available as async functions.\n\nCRITICAL - STATELESS EXECUTION:\nEach call is a fresh Python interpreter. Variables, imports, and data do NOT persist between calls.\nYou MUST complete your entire workflow in ONE code block: query → process → output.\nDO NOT split work across multiple calls expecting to reuse variables.\n\nYour code is auto-wrapped in async context. Just write logic with await—no boilerplate needed.\n\nExample (Complete workflow in one call):\n  # Query data\n  data = await query_database(sql=\"SELECT * FROM users\")\n  # Process it\n  df = pd.DataFrame(data)\n  summary = df.groupby('region').sum()\n  # Output results\n  await write_to_sheet(spreadsheet_id=sid, data=summary.to_dict())\n  print(f\"Wrote {len(summary)} rows\")\n\nExample (Parallel calls):\n  sf, ny = await asyncio.gather(get_weather(city=\"SF\"), get_weather(city=\"NY\"))\n  print(f\"SF: {sf}, NY: {ny}\")\n\nRules:\n- EVERYTHING in one call—no state persists between executions\n- Just write code with await—auto-wrapped in async context\n- DO NOT define async def main() or call asyncio.run()\n- Tools are pre-defined—DO NOT write function definitions\n- Only print() output returns to the model`\n    ),\n  timeout: z\n    .number()\n    .int()\n    .min(1000)\n    .max(300000)\n    .optional()\n    .default(DEFAULT_TIMEOUT)\n    .describe(\n      'Maximum execution time in milliseconds. Default: 60 seconds. Max: 5 minutes.'\n    ),\n});\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/** Python reserved keywords that get `_tool` suffix in Code API */\nconst PYTHON_KEYWORDS = new Set([\n  'False',\n  'None',\n  'True',\n  'and',\n  'as',\n  'assert',\n  'async',\n  'await',\n  'break',\n  'class',\n  'continue',\n  'def',\n  'del',\n  'elif',\n  'else',\n  'except',\n  'finally',\n  'for',\n  'from',\n  'global',\n  'if',\n  'import',\n  'in',\n  'is',\n  'lambda',\n  'nonlocal',\n  'not',\n  'or',\n  'pass',\n  'raise',\n  'return',\n  'try',\n  'while',\n  'with',\n  'yield',\n]);\n\n/**\n * Normalizes a tool name to Python identifier format.\n * Must match the Code API's `normalizePythonFunctionName` exactly:\n * 1. Replace hyphens and spaces with underscores\n * 2. Remove any other invalid characters\n * 3. Prefix with underscore if starts with number\n * 4. Append `_tool` if it's a Python keyword\n * @param name - The tool name to normalize\n * @returns Normalized Python-safe identifier\n */\nexport function normalizeToPythonIdentifier(name: string): string {\n  let normalized = name.replace(/[-\\s]/g, '_');\n\n  normalized = normalized.replace(/[^a-zA-Z0-9_]/g, '');\n\n  if (/^[0-9]/.test(normalized)) {\n    normalized = '_' + normalized;\n  }\n\n  if (PYTHON_KEYWORDS.has(normalized)) {\n    normalized = normalized + '_tool';\n  }\n\n  return normalized;\n}\n\n/**\n * Extracts tool names that are actually called in the Python code.\n * Handles hyphen/underscore conversion since Python identifiers use underscores.\n * @param code - The Python code to analyze\n * @param toolNameMap - Map from normalized Python name to original tool name\n * @returns Set of original tool names found in the code\n */\nexport function extractUsedToolNames(\n  code: string,\n  toolNameMap: Map<string, string>\n): Set<string> {\n  const usedTools = new Set<string>();\n\n  for (const [pythonName, originalName] of toolNameMap) {\n    const escapedName = pythonName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    const pattern = new RegExp(`\\\\b${escapedName}\\\\s*\\\\(`, 'g');\n\n    if (pattern.test(code)) {\n      usedTools.add(originalName);\n    }\n  }\n\n  return usedTools;\n}\n\n/**\n * Filters tool definitions to only include tools actually used in the code.\n * Handles the hyphen-to-underscore conversion for Python compatibility.\n * @param toolDefs - All available tool definitions\n * @param code - The Python code to analyze\n * @param debug - Enable debug logging\n * @returns Filtered array of tool definitions\n */\nexport function filterToolsByUsage(\n  toolDefs: t.LCTool[],\n  code: string,\n  debug = false\n): t.LCTool[] {\n  const toolNameMap = new Map<string, string>();\n  for (const tool of toolDefs) {\n    const pythonName = normalizeToPythonIdentifier(tool.name);\n    toolNameMap.set(pythonName, tool.name);\n  }\n\n  const usedToolNames = extractUsedToolNames(code, toolNameMap);\n\n  if (debug) {\n    // eslint-disable-next-line no-console\n    console.log(\n      `[PTC Debug] Tool filtering: found ${usedToolNames.size}/${toolDefs.length} tools in code`\n    );\n    if (usedToolNames.size > 0) {\n      // eslint-disable-next-line no-console\n      console.log(\n        `[PTC Debug] Matched tools: ${Array.from(usedToolNames).join(', ')}`\n      );\n    }\n  }\n\n  if (usedToolNames.size === 0) {\n    if (debug) {\n      // eslint-disable-next-line no-console\n      console.log(\n        '[PTC Debug] No tools detected in code - sending all tools as fallback'\n      );\n    }\n    return toolDefs;\n  }\n\n  return toolDefs.filter((tool) => usedToolNames.has(tool.name));\n}\n\n/**\n * Fetches files from a previous session to make them available for the current execution.\n * Files are returned as CodeEnvFile references to be included in the request.\n * @param baseUrl - The base URL for the Code API\n * @param apiKey - The API key for authentication\n * @param sessionId - The session ID to fetch files from\n * @param proxy - Optional HTTP proxy URL\n * @returns Array of CodeEnvFile references, or empty array if fetch fails\n */\nexport async function fetchSessionFiles(\n  baseUrl: string,\n  apiKey: string,\n  sessionId: string,\n  proxy?: string\n): Promise<t.CodeEnvFile[]> {\n  try {\n    const filesEndpoint = `${baseUrl}/files/${sessionId}?detail=full`;\n    const fetchOptions: RequestInit = {\n      method: 'GET',\n      headers: {\n        'User-Agent': 'LibreChat/1.0',\n        'X-API-Key': apiKey,\n      },\n    };\n\n    if (proxy != null && proxy !== '') {\n      fetchOptions.agent = new HttpsProxyAgent(proxy);\n    }\n\n    const response = await fetch(filesEndpoint, fetchOptions);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch files for session: ${response.status}`);\n    }\n\n    const files = await response.json();\n    if (!Array.isArray(files) || files.length === 0) {\n      return [];\n    }\n\n    return files.map((file: Record<string, unknown>) => {\n      // Extract the ID from the file name (part after session ID prefix and before extension)\n      const nameParts = (file.name as string).split('/');\n      const id = nameParts.length > 1 ? nameParts[1].split('.')[0] : '';\n\n      return {\n        session_id: sessionId,\n        id,\n        name: (file.metadata as Record<string, unknown>)[\n          'original-filename'\n        ] as string,\n      };\n    });\n  } catch (error) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `Failed to fetch files for session: ${sessionId}, ${(error as Error).message}`\n    );\n    return [];\n  }\n}\n\n/**\n * Makes an HTTP request to the Code API.\n * @param endpoint - The API endpoint URL\n * @param apiKey - The API key for authentication\n * @param body - The request body\n * @param proxy - Optional HTTP proxy URL\n * @returns The parsed API response\n */\nexport async function makeRequest(\n  endpoint: string,\n  apiKey: string,\n  body: Record<string, unknown>,\n  proxy?: string\n): Promise<t.ProgrammaticExecutionResponse> {\n  const fetchOptions: RequestInit = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'User-Agent': 'LibreChat/1.0',\n      'X-API-Key': apiKey,\n    },\n    body: JSON.stringify(body),\n  };\n\n  if (proxy != null && proxy !== '') {\n    fetchOptions.agent = new HttpsProxyAgent(proxy);\n  }\n\n  const response = await fetch(endpoint, fetchOptions);\n\n  if (!response.ok) {\n    const errorText = await response.text();\n    throw new Error(\n      `HTTP error! status: ${response.status}, body: ${errorText}`\n    );\n  }\n\n  return (await response.json()) as t.ProgrammaticExecutionResponse;\n}\n\n/**\n * Unwraps tool responses that may be formatted as tuples or content blocks.\n * MCP tools return [content, artifacts], we need to extract the raw data.\n * @param result - The raw result from tool.invoke()\n * @param isMCPTool - Whether this is an MCP tool (has mcp property)\n * @returns Unwrapped raw data (string, object, or parsed JSON)\n */\nexport function unwrapToolResponse(\n  result: unknown,\n  isMCPTool: boolean\n): unknown {\n  // Only unwrap if this is an MCP tool and result is a tuple\n  if (!isMCPTool) {\n    return result;\n  }\n\n  /**\n   * Checks if a value is a content block object (has type and text).\n   */\n  const isContentBlock = (value: unknown): boolean => {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      return false;\n    }\n    const obj = value as Record<string, unknown>;\n    return typeof obj.type === 'string';\n  };\n\n  /**\n   * Checks if an array is an array of content blocks.\n   */\n  const isContentBlockArray = (arr: unknown[]): boolean => {\n    return arr.length > 0 && arr.every(isContentBlock);\n  };\n\n  /**\n   * Extracts text from a single content block object.\n   * Returns the text if it's a text block, otherwise returns null.\n   */\n  const extractTextFromBlock = (block: unknown): string | null => {\n    if (typeof block !== 'object' || block === null) return null;\n    const b = block as Record<string, unknown>;\n    if (b.type === 'text' && typeof b.text === 'string') {\n      return b.text;\n    }\n    return null;\n  };\n\n  /**\n   * Extracts text from content blocks (array or single object).\n   * Returns combined text or null if no text blocks found.\n   */\n  const extractTextFromContent = (content: unknown): string | null => {\n    // Single content block object: { type: 'text', text: '...' }\n    if (\n      typeof content === 'object' &&\n      content !== null &&\n      !Array.isArray(content)\n    ) {\n      const text = extractTextFromBlock(content);\n      if (text !== null) return text;\n    }\n\n    // Array of content blocks: [{ type: 'text', text: '...' }, ...]\n    if (Array.isArray(content) && content.length > 0) {\n      const texts = content\n        .map(extractTextFromBlock)\n        .filter((t): t is string => t !== null);\n      if (texts.length > 0) {\n        return texts.join('\\n');\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Tries to parse a string as JSON if it looks like JSON.\n   */\n  const maybeParseJSON = (str: string): unknown => {\n    const trimmed = str.trim();\n    if (trimmed.startsWith('{') || trimmed.startsWith('[')) {\n      try {\n        return JSON.parse(trimmed);\n      } catch {\n        return str;\n      }\n    }\n    return str;\n  };\n\n  // Handle array of content blocks at top level FIRST\n  // (before checking for tuple, since both are arrays)\n  if (Array.isArray(result) && isContentBlockArray(result)) {\n    const extractedText = extractTextFromContent(result);\n    if (extractedText !== null) {\n      return maybeParseJSON(extractedText);\n    }\n  }\n\n  // Check if result is a tuple/array with [content, artifacts]\n  if (Array.isArray(result) && result.length >= 1) {\n    const [content] = result;\n\n    // If first element is a string, return it (possibly parsed as JSON)\n    if (typeof content === 'string') {\n      return maybeParseJSON(content);\n    }\n\n    // Try to extract text from content blocks\n    const extractedText = extractTextFromContent(content);\n    if (extractedText !== null) {\n      return maybeParseJSON(extractedText);\n    }\n\n    // If first element is an object (but not a text block), return it\n    if (typeof content === 'object' && content !== null) {\n      return content;\n    }\n  }\n\n  // Handle single content block object at top level (not in tuple)\n  const extractedText = extractTextFromContent(result);\n  if (extractedText !== null) {\n    return maybeParseJSON(extractedText);\n  }\n\n  // Not a formatted response, return as-is\n  return result;\n}\n\n/**\n * Executes tools in parallel when requested by the API.\n * Uses Promise.all for parallel execution, catching individual errors.\n * Unwraps formatted responses (e.g., MCP tool tuples) to raw data.\n * @param toolCalls - Array of tool calls from the API\n * @param toolMap - Map of tool names to executable tools\n * @returns Array of tool results\n */\nexport async function executeTools(\n  toolCalls: t.PTCToolCall[],\n  toolMap: t.ToolMap\n): Promise<t.PTCToolResult[]> {\n  const executions = toolCalls.map(async (call): Promise<t.PTCToolResult> => {\n    const tool = toolMap.get(call.name);\n\n    if (!tool) {\n      return {\n        call_id: call.id,\n        result: null,\n        is_error: true,\n        error_message: `Tool '${call.name}' not found. Available tools: ${Array.from(toolMap.keys()).join(', ')}`,\n      };\n    }\n\n    try {\n      const result = await tool.invoke(call.input, {\n        metadata: { [Constants.PROGRAMMATIC_TOOL_CALLING]: true },\n      });\n\n      const isMCPTool = tool.mcp === true;\n      const unwrappedResult = unwrapToolResponse(result, isMCPTool);\n\n      return {\n        call_id: call.id,\n        result: unwrappedResult,\n        is_error: false,\n      };\n    } catch (error) {\n      return {\n        call_id: call.id,\n        result: null,\n        is_error: true,\n        error_message: (error as Error).message || 'Tool execution failed',\n      };\n    }\n  });\n\n  return await Promise.all(executions);\n}\n\n/**\n * Formats the completed response for the agent.\n * @param response - The completed API response\n * @returns Tuple of [formatted string, artifact]\n */\nexport function formatCompletedResponse(\n  response: t.ProgrammaticExecutionResponse\n): [string, t.ProgrammaticExecutionArtifact] {\n  let formatted = '';\n\n  if (response.stdout != null && response.stdout !== '') {\n    formatted += `stdout:\\n${response.stdout}\\n`;\n  } else {\n    formatted += emptyOutputMessage;\n  }\n\n  if (response.stderr != null && response.stderr !== '') {\n    formatted += `stderr:\\n${response.stderr}\\n`;\n  }\n\n  if (response.files && response.files.length > 0) {\n    formatted += 'Generated files:\\n';\n\n    const fileCount = response.files.length;\n    for (let i = 0; i < fileCount; i++) {\n      const file = response.files[i];\n      const isImage = imageExtRegex.test(file.name);\n      formatted += `- /mnt/data/${file.name} | ${isImage ? imageMessage : otherMessage}`;\n\n      if (i < fileCount - 1) {\n        formatted += fileCount <= 3 ? ', ' : ',\\n';\n      }\n    }\n\n    formatted += `\\n\\n${accessMessage}`;\n  }\n\n  return [\n    formatted.trim(),\n    {\n      session_id: response.session_id,\n      files: response.files,\n    },\n  ];\n}\n\n// ============================================================================\n// Tool Factory\n// ============================================================================\n\n/**\n * Creates a Programmatic Tool Calling tool for complex multi-tool workflows.\n *\n * This tool enables AI agents to write Python code that orchestrates multiple\n * tool calls programmatically, reducing LLM round-trips and token usage.\n *\n * The tool map must be provided at runtime via config.configurable.toolMap.\n *\n * @param params - Configuration parameters (apiKey, baseUrl, maxRoundTrips, proxy)\n * @returns A LangChain DynamicStructuredTool for programmatic tool calling\n *\n * @example\n * const ptcTool = createProgrammaticToolCallingTool({\n *   apiKey: process.env.CODE_API_KEY,\n *   maxRoundTrips: 20\n * });\n *\n * const [output, artifact] = await ptcTool.invoke(\n *   { code, tools },\n *   { configurable: { toolMap } }\n * );\n */\nexport function createProgrammaticToolCallingTool(\n  initParams: t.ProgrammaticToolCallingParams = {}\n): DynamicStructuredTool<typeof ProgrammaticToolCallingSchema> {\n  const apiKey =\n    (initParams[EnvVar.CODE_API_KEY] as string | undefined) ??\n    initParams.apiKey ??\n    getEnvironmentVariable(EnvVar.CODE_API_KEY) ??\n    '';\n\n  if (!apiKey) {\n    throw new Error(\n      'No API key provided for programmatic tool calling. ' +\n        'Set CODE_API_KEY environment variable or pass apiKey in initParams.'\n    );\n  }\n\n  const baseUrl = initParams.baseUrl ?? getCodeBaseURL();\n  const maxRoundTrips = initParams.maxRoundTrips ?? DEFAULT_MAX_ROUND_TRIPS;\n  const proxy = initParams.proxy ?? process.env.PROXY;\n  const debug = initParams.debug ?? process.env.PTC_DEBUG === 'true';\n  const EXEC_ENDPOINT = `${baseUrl}/exec/programmatic`;\n\n  const description = `\nRun tools via Python code. Auto-wrapped in async context—just use \\`await\\` directly.\n\nCRITICAL - STATELESS: Each call is a fresh interpreter. Variables/imports do NOT persist.\nComplete your ENTIRE workflow in ONE call: fetch → process → save. No splitting across calls.\n\nRules:\n- Everything in ONE code block—no state carries over between executions\n- Do NOT define \\`async def main()\\` or call \\`asyncio.run()\\`—just write code with await\n- Tools are pre-defined—DO NOT write function definitions\n- Only \\`print()\\` output returns; tool results are raw dicts/lists/strings\n- Generated files are automatically available in /mnt/data/ for subsequent executions\n- Tool names normalized: hyphens→underscores, keywords get \\`_tool\\` suffix\n\nWhen to use: loops, conditionals, parallel (\\`asyncio.gather\\`), multi-step pipelines.\n\nExample (complete pipeline):\n  data = await query_db(sql=\"...\"); df = process(data); await save_to_sheet(data=df); print(\"Done\")\n`.trim();\n\n  return tool<typeof ProgrammaticToolCallingSchema>(\n    async (params, config) => {\n      const { code, timeout = DEFAULT_TIMEOUT } = params;\n\n      // Extra params injected by ToolNode (follows web_search pattern)\n      const { toolMap, toolDefs, session_id, _injected_files } =\n        (config.toolCall ?? {}) as ToolCall &\n          Partial<t.ProgrammaticCache> & {\n            session_id?: string;\n            _injected_files?: t.CodeEnvFile[];\n          };\n\n      if (toolMap == null || toolMap.size === 0) {\n        throw new Error(\n          'No toolMap provided. ' +\n            'ToolNode should inject this from AgentContext when invoked through the graph.'\n        );\n      }\n\n      if (toolDefs == null || toolDefs.length === 0) {\n        throw new Error(\n          'No tool definitions provided. ' +\n            'Either pass tools in the input or ensure ToolNode injects toolDefs.'\n        );\n      }\n\n      let roundTrip = 0;\n\n      try {\n        // ====================================================================\n        // Phase 1: Filter tools and make initial request\n        // ====================================================================\n\n        const effectiveTools = filterToolsByUsage(toolDefs, code, debug);\n\n        if (debug) {\n          // eslint-disable-next-line no-console\n          console.log(\n            `[PTC Debug] Sending ${effectiveTools.length} tools to API ` +\n              `(filtered from ${toolDefs.length})`\n          );\n        }\n\n        /**\n         * File injection priority:\n         * 1. Use _injected_files from ToolNode (avoids /files endpoint race condition)\n         * 2. Fall back to fetching from /files endpoint if session_id provided but no injected files\n         */\n        let files: t.CodeEnvFile[] | undefined;\n        if (_injected_files && _injected_files.length > 0) {\n          files = _injected_files;\n        } else if (session_id != null && session_id.length > 0) {\n          files = await fetchSessionFiles(baseUrl, apiKey, session_id, proxy);\n        }\n\n        let response = await makeRequest(\n          EXEC_ENDPOINT,\n          apiKey,\n          {\n            code,\n            tools: effectiveTools,\n            session_id,\n            timeout,\n            ...(files && files.length > 0 ? { files } : {}),\n          },\n          proxy\n        );\n\n        // ====================================================================\n        // Phase 2: Handle response loop\n        // ====================================================================\n\n        while (response.status === 'tool_call_required') {\n          roundTrip++;\n\n          if (roundTrip > maxRoundTrips) {\n            throw new Error(\n              `Exceeded maximum round trips (${maxRoundTrips}). ` +\n                'This may indicate an infinite loop, excessive tool calls, ' +\n                'or a logic error in your code.'\n            );\n          }\n\n          if (debug) {\n            // eslint-disable-next-line no-console\n            console.log(\n              `[PTC Debug] Round trip ${roundTrip}: ${response.tool_calls?.length ?? 0} tool(s) to execute`\n            );\n          }\n\n          const toolResults = await executeTools(\n            response.tool_calls ?? [],\n            toolMap\n          );\n\n          response = await makeRequest(\n            EXEC_ENDPOINT,\n            apiKey,\n            {\n              continuation_token: response.continuation_token,\n              tool_results: toolResults,\n            },\n            proxy\n          );\n        }\n\n        // ====================================================================\n        // Phase 3: Handle final state\n        // ====================================================================\n\n        if (response.status === 'completed') {\n          return formatCompletedResponse(response);\n        }\n\n        if (response.status === 'error') {\n          throw new Error(\n            `Execution error: ${response.error}` +\n              (response.stderr != null && response.stderr !== ''\n                ? `\\n\\nStderr:\\n${response.stderr}`\n                : '')\n          );\n        }\n\n        throw new Error(`Unexpected response status: ${response.status}`);\n      } catch (error) {\n        throw new Error(\n          `Programmatic execution failed: ${(error as Error).message}`\n        );\n      }\n    },\n    {\n      name: Constants.PROGRAMMATIC_TOOL_CALLING,\n      description,\n      schema: ProgrammaticToolCallingSchema,\n      responseFormat: Constants.CONTENT_AND_ARTIFACT,\n    }\n  );\n}\n"],"names":["config","z","HttpsProxyAgent","Constants","imageExtRegex","EnvVar","getEnvironmentVariable","getCodeBaseURL","tool"],"mappings":"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"}