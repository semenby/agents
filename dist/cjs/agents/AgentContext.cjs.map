{"version":3,"file":"AgentContext.cjs","sources":["../../../src/agents/AgentContext.ts"],"sourcesContent":["/* eslint-disable no-console */\n// src/agents/AgentContext.ts\nimport { zodToJsonSchema } from 'zod-to-json-schema';\nimport { SystemMessage } from '@langchain/core/messages';\nimport { RunnableLambda } from '@langchain/core/runnables';\nimport type {\n  UsageMetadata,\n  BaseMessage,\n  BaseMessageFields,\n} from '@langchain/core/messages';\nimport type { RunnableConfig, Runnable } from '@langchain/core/runnables';\nimport type * as t from '@/types';\nimport type { createPruneMessages } from '@/messages';\nimport { ContentTypes, Providers } from '@/common';\n\n/**\n * Encapsulates agent-specific state that can vary between agents in a multi-agent system\n */\nexport class AgentContext {\n  /**\n   * Create an AgentContext from configuration with token accounting initialization\n   */\n  static fromConfig(\n    agentConfig: t.AgentInputs,\n    tokenCounter?: t.TokenCounter,\n    indexTokenCountMap?: Record<string, number>\n  ): AgentContext {\n    const {\n      agentId,\n      name,\n      provider,\n      clientOptions,\n      tools,\n      toolMap,\n      toolEnd,\n      toolRegistry,\n      instructions,\n      additional_instructions,\n      streamBuffer,\n      maxContextTokens,\n      reasoningKey,\n      useLegacyContent,\n    } = agentConfig;\n\n    const agentContext = new AgentContext({\n      agentId,\n      name: name ?? agentId,\n      provider,\n      clientOptions,\n      maxContextTokens,\n      streamBuffer,\n      tools,\n      toolMap,\n      toolRegistry,\n      instructions,\n      additionalInstructions: additional_instructions,\n      reasoningKey,\n      toolEnd,\n      instructionTokens: 0,\n      tokenCounter,\n      useLegacyContent,\n    });\n\n    if (tokenCounter) {\n      // Initialize system runnable BEFORE async tool token calculation\n      // This ensures system message tokens are in instructionTokens before\n      // updateTokenMapWithInstructions is called\n      agentContext.initializeSystemRunnable();\n\n      const tokenMap = indexTokenCountMap || {};\n      agentContext.indexTokenCountMap = tokenMap;\n      agentContext.tokenCalculationPromise = agentContext\n        .calculateInstructionTokens(tokenCounter)\n        .then(() => {\n          // Update token map with instruction tokens (includes system + tool tokens)\n          agentContext.updateTokenMapWithInstructions(tokenMap);\n        })\n        .catch((err) => {\n          console.error('Error calculating instruction tokens:', err);\n        });\n    } else if (indexTokenCountMap) {\n      agentContext.indexTokenCountMap = indexTokenCountMap;\n    }\n\n    return agentContext;\n  }\n\n  /** Agent identifier */\n  agentId: string;\n  /** Human-readable name for this agent (used in handoff context). Falls back to agentId if not provided. */\n  name?: string;\n  /** Provider for this specific agent */\n  provider: Providers;\n  /** Client options for this agent */\n  clientOptions?: t.ClientOptions;\n  /** Token count map indexed by message position */\n  indexTokenCountMap: Record<string, number | undefined> = {};\n  /** Maximum context tokens for this agent */\n  maxContextTokens?: number;\n  /** Current usage metadata for this agent */\n  currentUsage?: Partial<UsageMetadata>;\n  /** Prune messages function configured for this agent */\n  pruneMessages?: ReturnType<typeof createPruneMessages>;\n  /** Token counter function for this agent */\n  tokenCounter?: t.TokenCounter;\n  /** Instructions/system message token count */\n  instructionTokens: number = 0;\n  /** The amount of time that should pass before another consecutive API call */\n  streamBuffer?: number;\n  /** Last stream call timestamp for rate limiting */\n  lastStreamCall?: number;\n  /** Tools available to this agent */\n  tools?: t.GraphTools;\n  /** Tool map for this agent */\n  toolMap?: t.ToolMap;\n  /**\n   * Tool definitions registry (includes deferred and programmatic tool metadata).\n   * Used for tool search and programmatic tool calling.\n   */\n  toolRegistry?: t.LCToolRegistry;\n  /** Set of tool names discovered via tool search (to be loaded) */\n  discoveredToolNames: Set<string> = new Set();\n  /** Instructions for this agent */\n  instructions?: string;\n  /** Additional instructions for this agent */\n  additionalInstructions?: string;\n  /** Reasoning key for this agent */\n  reasoningKey: 'reasoning_content' | 'reasoning' = 'reasoning_content';\n  /** Last token for reasoning detection */\n  lastToken?: string;\n  /** Token type switch state */\n  tokenTypeSwitch?: 'reasoning' | 'content';\n  /** Current token type being processed */\n  currentTokenType: ContentTypes.TEXT | ContentTypes.THINK | 'think_and_text' =\n    ContentTypes.TEXT;\n  /** Whether tools should end the workflow */\n  toolEnd: boolean = false;\n  /** Cached system runnable (created lazily) */\n  private cachedSystemRunnable?: Runnable<\n    BaseMessage[],\n    (BaseMessage | SystemMessage)[],\n    RunnableConfig<Record<string, unknown>>\n  >;\n  /** Whether system runnable needs rebuild (set when discovered tools change) */\n  private systemRunnableStale: boolean = true;\n  /** Cached system message token count (separate from tool tokens) */\n  private systemMessageTokens: number = 0;\n  /** Promise for token calculation initialization */\n  tokenCalculationPromise?: Promise<void>;\n  /** Format content blocks as strings (for legacy compatibility) */\n  useLegacyContent: boolean = false;\n  /**\n   * Handoff context when this agent receives control via handoff.\n   * Contains source and parallel execution info for system message context.\n   */\n  handoffContext?: {\n    /** Source agent that transferred control */\n    sourceAgentName: string;\n    /** Names of sibling agents executing in parallel (empty if sequential) */\n    parallelSiblings: string[];\n  };\n\n  constructor({\n    agentId,\n    name,\n    provider,\n    clientOptions,\n    maxContextTokens,\n    streamBuffer,\n    tokenCounter,\n    tools,\n    toolMap,\n    toolRegistry,\n    instructions,\n    additionalInstructions,\n    reasoningKey,\n    toolEnd,\n    instructionTokens,\n    useLegacyContent,\n  }: {\n    agentId: string;\n    name?: string;\n    provider: Providers;\n    clientOptions?: t.ClientOptions;\n    maxContextTokens?: number;\n    streamBuffer?: number;\n    tokenCounter?: t.TokenCounter;\n    tools?: t.GraphTools;\n    toolMap?: t.ToolMap;\n    toolRegistry?: t.LCToolRegistry;\n    instructions?: string;\n    additionalInstructions?: string;\n    reasoningKey?: 'reasoning_content' | 'reasoning';\n    toolEnd?: boolean;\n    instructionTokens?: number;\n    useLegacyContent?: boolean;\n  }) {\n    this.agentId = agentId;\n    this.name = name;\n    this.provider = provider;\n    this.clientOptions = clientOptions;\n    this.maxContextTokens = maxContextTokens;\n    this.streamBuffer = streamBuffer;\n    this.tokenCounter = tokenCounter;\n    this.tools = tools;\n    this.toolMap = toolMap;\n    this.toolRegistry = toolRegistry;\n    this.instructions = instructions;\n    this.additionalInstructions = additionalInstructions;\n    if (reasoningKey) {\n      this.reasoningKey = reasoningKey;\n    }\n    if (toolEnd !== undefined) {\n      this.toolEnd = toolEnd;\n    }\n    if (instructionTokens !== undefined) {\n      this.instructionTokens = instructionTokens;\n    }\n\n    this.useLegacyContent = useLegacyContent ?? false;\n  }\n\n  /**\n   * Builds instructions text for tools that are ONLY callable via programmatic code execution.\n   * These tools cannot be called directly by the LLM but are available through the\n   * run_tools_with_code tool.\n   *\n   * Includes:\n   * - Code_execution-only tools that are NOT deferred\n   * - Code_execution-only tools that ARE deferred but have been discovered via tool search\n   */\n  private buildProgrammaticOnlyToolsInstructions(): string {\n    if (!this.toolRegistry) return '';\n\n    const programmaticOnlyTools: t.LCTool[] = [];\n    for (const [name, toolDef] of this.toolRegistry) {\n      const allowedCallers = toolDef.allowed_callers ?? ['direct'];\n      const isCodeExecutionOnly =\n        allowedCallers.includes('code_execution') &&\n        !allowedCallers.includes('direct');\n\n      if (!isCodeExecutionOnly) continue;\n\n      // Include if: not deferred OR deferred but discovered\n      const isDeferred = toolDef.defer_loading === true;\n      const isDiscovered = this.discoveredToolNames.has(name);\n      if (!isDeferred || isDiscovered) {\n        programmaticOnlyTools.push(toolDef);\n      }\n    }\n\n    if (programmaticOnlyTools.length === 0) return '';\n\n    const toolDescriptions = programmaticOnlyTools\n      .map((tool) => {\n        let desc = `- **${tool.name}**`;\n        if (tool.description != null && tool.description !== '') {\n          desc += `: ${tool.description}`;\n        }\n        if (tool.parameters) {\n          desc += `\\n  Parameters: ${JSON.stringify(tool.parameters, null, 2).replace(/\\n/g, '\\n  ')}`;\n        }\n        return desc;\n      })\n      .join('\\n\\n');\n\n    return (\n      '\\n\\n## Programmatic-Only Tools\\n\\n' +\n      'The following tools are available exclusively through the `run_tools_with_code` tool. ' +\n      'You cannot call these tools directly; instead, use `run_tools_with_code` with Python code that invokes them.\\n\\n' +\n      toolDescriptions\n    );\n  }\n\n  /**\n   * Gets the system runnable, creating it lazily if needed.\n   * Includes instructions, additional instructions, and programmatic-only tools documentation.\n   * Only rebuilds when marked stale (via markToolsAsDiscovered).\n   */\n  get systemRunnable():\n    | Runnable<\n        BaseMessage[],\n        (BaseMessage | SystemMessage)[],\n        RunnableConfig<Record<string, unknown>>\n      >\n    | undefined {\n    // Return cached if not stale\n    if (!this.systemRunnableStale && this.cachedSystemRunnable !== undefined) {\n      return this.cachedSystemRunnable;\n    }\n\n    // Stale or first access - rebuild\n    const instructionsString = this.buildInstructionsString();\n    this.cachedSystemRunnable = this.buildSystemRunnable(instructionsString);\n    this.systemRunnableStale = false;\n    return this.cachedSystemRunnable;\n  }\n\n  /**\n   * Explicitly initializes the system runnable.\n   * Call this before async token calculation to ensure system message tokens are counted first.\n   */\n  initializeSystemRunnable(): void {\n    if (this.systemRunnableStale || this.cachedSystemRunnable === undefined) {\n      const instructionsString = this.buildInstructionsString();\n      this.cachedSystemRunnable = this.buildSystemRunnable(instructionsString);\n      this.systemRunnableStale = false;\n    }\n  }\n\n  /**\n   * Builds the raw instructions string (without creating SystemMessage).\n   * Includes agent identity preamble and handoff context when available.\n   */\n  private buildInstructionsString(): string {\n    const parts: string[] = [];\n\n    /** Build agent identity and handoff context preamble */\n    const identityPreamble = this.buildIdentityPreamble();\n    if (identityPreamble) {\n      parts.push(identityPreamble);\n    }\n\n    /** Add main instructions */\n    if (this.instructions != null && this.instructions !== '') {\n      parts.push(this.instructions);\n    }\n\n    /** Add additional instructions */\n    if (\n      this.additionalInstructions != null &&\n      this.additionalInstructions !== ''\n    ) {\n      parts.push(this.additionalInstructions);\n    }\n\n    /** Add programmatic tools documentation */\n    const programmaticToolsDoc = this.buildProgrammaticOnlyToolsInstructions();\n    if (programmaticToolsDoc) {\n      parts.push(programmaticToolsDoc);\n    }\n\n    return parts.join('\\n\\n');\n  }\n\n  /**\n   * Builds the agent identity preamble including handoff context if present.\n   * This helps the agent understand its role in the multi-agent workflow.\n   */\n  private buildIdentityPreamble(): string {\n    if (!this.handoffContext) return '';\n\n    const displayName = this.name ?? this.agentId;\n    const { sourceAgentName, parallelSiblings } = this.handoffContext;\n    const isParallel = parallelSiblings.length > 0;\n\n    const lines: string[] = [];\n    lines.push('## Multi-Agent Workflow');\n    lines.push(\n      `You are \"${displayName}\", transferred from \"${sourceAgentName}\".`\n    );\n\n    if (isParallel) {\n      lines.push(`Running in parallel with: ${parallelSiblings.join(', ')}.`);\n    }\n\n    lines.push(\n      'Execute only tasks relevant to your role. Routing is already handled if requested, unless you can route further.'\n    );\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Build system runnable from pre-built instructions string.\n   * Only called when content has actually changed.\n   */\n  private buildSystemRunnable(\n    instructionsString: string\n  ):\n    | Runnable<\n        BaseMessage[],\n        (BaseMessage | SystemMessage)[],\n        RunnableConfig<Record<string, unknown>>\n      >\n    | undefined {\n    if (!instructionsString) {\n      // Remove previous tokens if we had a system message before\n      this.instructionTokens -= this.systemMessageTokens;\n      this.systemMessageTokens = 0;\n      return undefined;\n    }\n\n    let finalInstructions: string | BaseMessageFields = instructionsString;\n\n    // Handle Anthropic prompt caching\n    if (this.provider === Providers.ANTHROPIC) {\n      const anthropicOptions = this.clientOptions as\n        | t.AnthropicClientOptions\n        | undefined;\n      if (anthropicOptions?.promptCache === true) {\n        finalInstructions = {\n          content: [\n            {\n              type: 'text',\n              text: instructionsString,\n              cache_control: { type: 'ephemeral' },\n            },\n          ],\n        };\n      }\n    }\n\n    const systemMessage = new SystemMessage(finalInstructions);\n\n    // Update token counts (subtract old, add new)\n    if (this.tokenCounter) {\n      this.instructionTokens -= this.systemMessageTokens;\n      this.systemMessageTokens = this.tokenCounter(systemMessage);\n      this.instructionTokens += this.systemMessageTokens;\n    }\n\n    return RunnableLambda.from((messages: BaseMessage[]) => {\n      return [systemMessage, ...messages];\n    }).withConfig({ runName: 'prompt' });\n  }\n\n  /**\n   * Reset context for a new run\n   */\n  reset(): void {\n    this.instructionTokens = 0;\n    this.systemMessageTokens = 0;\n    this.cachedSystemRunnable = undefined;\n    this.systemRunnableStale = true;\n    this.lastToken = undefined;\n    this.indexTokenCountMap = {};\n    this.currentUsage = undefined;\n    this.pruneMessages = undefined;\n    this.lastStreamCall = undefined;\n    this.tokenTypeSwitch = undefined;\n    this.currentTokenType = ContentTypes.TEXT;\n    this.discoveredToolNames.clear();\n    this.handoffContext = undefined;\n  }\n\n  /**\n   * Update the token count map with instruction tokens\n   */\n  updateTokenMapWithInstructions(baseTokenMap: Record<string, number>): void {\n    if (this.instructionTokens > 0) {\n      // Shift all indices by the instruction token count\n      const shiftedMap: Record<string, number> = {};\n      for (const [key, value] of Object.entries(baseTokenMap)) {\n        const index = parseInt(key, 10);\n        if (!isNaN(index)) {\n          shiftedMap[String(index)] =\n            value + (index === 0 ? this.instructionTokens : 0);\n        }\n      }\n      this.indexTokenCountMap = shiftedMap;\n    } else {\n      this.indexTokenCountMap = { ...baseTokenMap };\n    }\n  }\n\n  /**\n   * Calculate tool tokens and add to instruction tokens\n   * Note: System message tokens are calculated during systemRunnable creation\n   */\n  async calculateInstructionTokens(\n    tokenCounter: t.TokenCounter\n  ): Promise<void> {\n    let toolTokens = 0;\n    if (this.tools && this.tools.length > 0) {\n      for (const tool of this.tools) {\n        const genericTool = tool as Record<string, unknown>;\n        if (\n          genericTool.schema != null &&\n          typeof genericTool.schema === 'object'\n        ) {\n          const schema = genericTool.schema as {\n            describe: (desc: string) => unknown;\n          };\n          const describedSchema = schema.describe(\n            (genericTool.description as string) || ''\n          );\n          const jsonSchema = zodToJsonSchema(\n            describedSchema as Parameters<typeof zodToJsonSchema>[0],\n            (genericTool.name as string) || ''\n          );\n          toolTokens += tokenCounter(\n            new SystemMessage(JSON.stringify(jsonSchema))\n          );\n        }\n      }\n    }\n\n    // Add tool tokens to existing instruction tokens (which may already include system message tokens)\n    this.instructionTokens += toolTokens;\n  }\n\n  /**\n   * Gets the tool registry for deferred tools (for tool search).\n   * @param onlyDeferred If true, only returns tools with defer_loading=true\n   * @returns LCToolRegistry with tool definitions\n   */\n  getDeferredToolRegistry(onlyDeferred: boolean = true): t.LCToolRegistry {\n    const registry: t.LCToolRegistry = new Map();\n\n    if (!this.toolRegistry) {\n      return registry;\n    }\n\n    for (const [name, toolDef] of this.toolRegistry) {\n      if (!onlyDeferred || toolDef.defer_loading === true) {\n        registry.set(name, toolDef);\n      }\n    }\n\n    return registry;\n  }\n\n  /**\n   * Sets the handoff context for this agent.\n   * Call this when the agent receives control via handoff from another agent.\n   * Marks system runnable as stale to include handoff context in system message.\n   * @param sourceAgentName - Name of the agent that transferred control\n   * @param parallelSiblings - Names of other agents executing in parallel with this one\n   */\n  setHandoffContext(sourceAgentName: string, parallelSiblings: string[]): void {\n    this.handoffContext = { sourceAgentName, parallelSiblings };\n    this.systemRunnableStale = true;\n  }\n\n  /**\n   * Clears any handoff context.\n   * Call this when resetting the agent or when handoff context is no longer relevant.\n   */\n  clearHandoffContext(): void {\n    if (this.handoffContext) {\n      this.handoffContext = undefined;\n      this.systemRunnableStale = true;\n    }\n  }\n\n  /**\n   * Marks tools as discovered via tool search.\n   * Discovered tools will be included in the next model binding.\n   * Only marks system runnable stale if NEW tools were actually added.\n   * @param toolNames - Array of discovered tool names\n   * @returns true if any new tools were discovered\n   */\n  markToolsAsDiscovered(toolNames: string[]): boolean {\n    let hasNewDiscoveries = false;\n    for (const name of toolNames) {\n      if (!this.discoveredToolNames.has(name)) {\n        this.discoveredToolNames.add(name);\n        hasNewDiscoveries = true;\n      }\n    }\n    if (hasNewDiscoveries) {\n      this.systemRunnableStale = true;\n    }\n    return hasNewDiscoveries;\n  }\n\n  /**\n   * Gets tools that should be bound to the LLM.\n   * Includes:\n   * 1. Non-deferred tools with allowed_callers: ['direct']\n   * 2. Discovered tools (from tool search)\n   * @returns Array of tools to bind to model\n   */\n  getToolsForBinding(): t.GraphTools | undefined {\n    if (!this.tools || !this.toolRegistry) {\n      return this.tools;\n    }\n\n    const toolsToInclude = this.tools.filter((tool) => {\n      if (!('name' in tool)) {\n        return true; // No name, include by default\n      }\n\n      const toolDef = this.toolRegistry?.get(tool.name);\n      if (!toolDef) {\n        return true; // Not in registry, include by default\n      }\n\n      // Check if discovered (overrides defer_loading)\n      if (this.discoveredToolNames.has(tool.name)) {\n        // Discovered tools must still have allowed_callers: ['direct']\n        const allowedCallers = toolDef.allowed_callers ?? ['direct'];\n        return allowedCallers.includes('direct');\n      }\n\n      // Not discovered: must be direct-callable AND not deferred\n      const allowedCallers = toolDef.allowed_callers ?? ['direct'];\n      return (\n        allowedCallers.includes('direct') && toolDef.defer_loading !== true\n      );\n    });\n\n    return toolsToInclude;\n  }\n}\n"],"names":["ContentTypes","Providers","SystemMessage","RunnableLambda","zodToJsonSchema"],"mappings":"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"}