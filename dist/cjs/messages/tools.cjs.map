{"version":3,"file":"tools.cjs","sources":["../../../src/messages/tools.ts"],"sourcesContent":["// src/messages/toolDiscovery.ts\nimport { AIMessageChunk, ToolMessage } from '@langchain/core/messages';\nimport type { BaseMessage } from '@langchain/core/messages';\nimport { Constants } from '@/common';\nimport { findLastIndex } from './core';\n\ntype ToolSearchArtifact = {\n  tool_references?: Array<{ tool_name: string }>;\n};\n\n/**\n * Extracts discovered tool names from tool search results in the current turn.\n * Only processes tool search messages after the latest AI message with tool calls.\n *\n * Similar pattern to formatArtifactPayload - finds relevant messages efficiently\n * by identifying the latest AI parent and only processing subsequent tool messages.\n *\n * @param messages - All messages in the conversation\n * @returns Array of discovered tool names (empty if no new discoveries)\n */\nexport function extractToolDiscoveries(messages: BaseMessage[]): string[] {\n  const lastMessage = messages[messages.length - 1];\n  if (!(lastMessage instanceof ToolMessage)) return [];\n\n  // Find the latest AIMessage with tool_calls that this tool message belongs to\n  const latestAIParentIndex = findLastIndex(\n    messages,\n    (msg) =>\n      (msg instanceof AIMessageChunk &&\n        (msg.tool_calls?.length ?? 0) > 0 &&\n        msg.tool_calls?.some((tc) => tc.id === lastMessage.tool_call_id)) ??\n      false\n  );\n\n  if (latestAIParentIndex === -1) return [];\n\n  // Collect tool_call_ids from the AI message\n  const aiMessage = messages[latestAIParentIndex] as AIMessageChunk;\n  const toolCallIds = new Set(aiMessage.tool_calls?.map((tc) => tc.id) ?? []);\n\n  // Only process tool search results after the AI message that belong to this turn\n  const discoveredNames: string[] = [];\n  for (let i = latestAIParentIndex + 1; i < messages.length; i++) {\n    const msg = messages[i];\n    if (!(msg instanceof ToolMessage)) continue;\n    if (msg.name !== Constants.TOOL_SEARCH) continue;\n    if (!toolCallIds.has(msg.tool_call_id)) continue;\n\n    // This is a tool search result from the current turn\n    if (typeof msg.artifact === 'object' && msg.artifact != null) {\n      const artifact = msg.artifact as ToolSearchArtifact;\n      if (artifact.tool_references && artifact.tool_references.length > 0) {\n        for (const ref of artifact.tool_references) {\n          discoveredNames.push(ref.tool_name);\n        }\n      }\n    }\n  }\n\n  return discoveredNames;\n}\n\n/**\n * Checks if the current turn has any tool search results.\n * Quick check to avoid full extraction when not needed.\n */\nexport function hasToolSearchInCurrentTurn(messages: BaseMessage[]): boolean {\n  const lastMessage = messages[messages.length - 1];\n  if (!(lastMessage instanceof ToolMessage)) return false;\n\n  // Find the latest AIMessage with tool_calls\n  const latestAIParentIndex = findLastIndex(\n    messages,\n    (msg) =>\n      (msg instanceof AIMessageChunk &&\n        (msg.tool_calls?.length ?? 0) > 0 &&\n        msg.tool_calls?.some((tc) => tc.id === lastMessage.tool_call_id)) ??\n      false\n  );\n\n  if (latestAIParentIndex === -1) return false;\n\n  const aiMessage = messages[latestAIParentIndex] as AIMessageChunk;\n  const toolCallIds = new Set(aiMessage.tool_calls?.map((tc) => tc.id) ?? []);\n\n  // Check if any tool search results exist after the AI message\n  for (let i = latestAIParentIndex + 1; i < messages.length; i++) {\n    const msg = messages[i];\n    if (\n      msg instanceof ToolMessage &&\n      msg.name === Constants.TOOL_SEARCH &&\n      toolCallIds.has(msg.tool_call_id)\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n"],"names":["messages","ToolMessage","findLastIndex","AIMessageChunk","Constants"],"mappings":"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"}